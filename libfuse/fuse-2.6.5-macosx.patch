diff -Naur old/README.MacFUSE new/README.MacFUSE
--- old/README.MacFUSE	1969-12-31 16:00:00.000000000 -0800
+++ new/README.MacFUSE	2007-06-05 16:47:13.000000000 -0700
@@ -0,0 +1,7 @@
+MacFUSE Project Page:
+
+http://code.google.com/p/macfuse/
+
+Making a Universal build:
+
+CFLAGS="-D__FreeBSD__=10 -D_POSIX_C_SOURCE=200112L -O -g -arch i386 -arch ppc -isysroot /Developer/SDKs/MacOSX10.4u.sdk" LDFLAGS="-arch i386 -arch ppc -framework CoreFoundation" ./configure --prefix=/usr/local --disable-dependency-tracking
diff -Naur old/configure new/configure
--- old/configure	2007-04-29 02:13:15.000000000 -0700
+++ new/configure	2007-06-05 16:46:06.000000000 -0700
@@ -11284,7 +11284,8 @@
 fi
 
 
-libfuse_libs=-pthread
+#libfuse_libs=-pthread
+libfuse_libs=
 LIBS=
 { echo "$as_me:$LINENO: checking for library containing clock_gettime" >&5
 echo $ECHO_N "checking for library containing clock_gettime... $ECHO_C" >&6; }
diff -Naur old/example/fusexmp.c new/example/fusexmp.c
--- old/example/fusexmp.c	2006-12-09 10:51:13.000000000 -0800
+++ new/example/fusexmp.c	2007-06-05 16:46:06.000000000 -0700
@@ -45,8 +45,25 @@
     int res;
 
     res = access(path, mask);
-    if (res == -1)
+    if (res == -1) {
+#if (__FreeBSD__ >= 10)
+        if (errno == ENOENT) {
+            int next_res;
+            struct stat sb;
+            next_res = lstat(path, &sb);
+            if (next_res == 0 && S_ISLNK(sb.st_mode) &&
+                ((sb.st_uid == getuid()) || (geteuid() == 0))) {
+                /*
+                 * The target of the symlink doesn't exist, but the
+                 * symlink itself does. A lame cheap fix here.
+                 */
+                return 0;
+            }
+            return -ENOENT;
+        }
+#endif
         return -errno;
+    }  /* if (res == -1) */
 
     return 0;
 }
@@ -314,7 +331,11 @@
 static int xmp_setxattr(const char *path, const char *name, const char *value,
                         size_t size, int flags)
 {
+#if (__FreeBSD__ >= 10)
+    int res = setxattr(path, name, value, size, 0, flags);
+#else
     int res = lsetxattr(path, name, value, size, flags);
+#endif
     if (res == -1)
         return -errno;
     return 0;
@@ -323,7 +344,11 @@
 static int xmp_getxattr(const char *path, const char *name, char *value,
                     size_t size)
 {
+#if (__FreeBSD__ >= 10)
+    int res = getxattr(path, name, value, size, 0, 0);
+#else
     int res = lgetxattr(path, name, value, size);
+#endif
     if (res == -1)
         return -errno;
     return res;
@@ -331,7 +356,11 @@
 
 static int xmp_listxattr(const char *path, char *list, size_t size)
 {
+#if (__FreeBSD__ >= 10)
+    int res = listxattr(path, list, size, 0);
+#else
     int res = llistxattr(path, list, size);
+#endif
     if (res == -1)
         return -errno;
     return res;
@@ -339,7 +368,11 @@
 
 static int xmp_removexattr(const char *path, const char *name)
 {
+#if (__FreeBSD__ >= 10)
+    int res = removexattr(path, name, 0);
+#else
     int res = lremovexattr(path, name);
+#endif
     if (res == -1)
         return -errno;
     return 0;
diff -Naur old/example/fusexmp_fh.c new/example/fusexmp_fh.c
--- old/example/fusexmp_fh.c	2007-04-15 12:31:57.000000000 -0700
+++ new/example/fusexmp_fh.c	2007-06-05 16:46:06.000000000 -0700
@@ -32,8 +32,9 @@
     int res;
 
     res = lstat(path, stbuf);
-    if (res == -1)
+    if (res == -1) {
         return -errno;
+    }
 
     return 0;
 }
@@ -57,8 +58,25 @@
     int res;
 
     res = access(path, mask);
-    if (res == -1)
+    if (res == -1) {
+#if (__FreeBSD__ >= 10)
+        if (errno == ENOENT) {
+            int next_res;
+            struct stat sb;
+            next_res = lstat(path, &sb);
+            if (next_res == 0 && S_ISLNK(sb.st_mode) &&
+                ((sb.st_uid == getuid()) || (geteuid() == 0))) {
+                /*
+                 * The target of the symlink doesn't exist, but the
+                 * symlink itself does. A lame cheap fix here.
+                 */
+                return 0;
+            }
+            return -ENOENT;
+        }
+#endif
         return -errno;
+    }  /* if (res == -1) */
 
     return 0;
 }
@@ -373,7 +391,11 @@
 static int xmp_setxattr(const char *path, const char *name, const char *value,
                         size_t size, int flags)
 {
+#if (__FreeBSD__ >= 10)
+    int res = setxattr(path, name, value, size, 0, flags);
+#else
     int res = lsetxattr(path, name, value, size, flags);
+#endif
     if (res == -1)
         return -errno;
     return 0;
@@ -382,7 +404,11 @@
 static int xmp_getxattr(const char *path, const char *name, char *value,
                     size_t size)
 {
+#if (__FreeBSD__ >= 10)
+    int res = getxattr(path, name, value, size, 0, 0);
+#else
     int res = lgetxattr(path, name, value, size);
+#endif
     if (res == -1)
         return -errno;
     return res;
@@ -390,7 +416,11 @@
 
 static int xmp_listxattr(const char *path, char *list, size_t size)
 {
+#if (__FreeBSD__ >= 10)
+    int res = listxattr(path, list, size, 0);
+#else
     int res = llistxattr(path, list, size);
+#endif
     if (res == -1)
         return -errno;
     return res;
@@ -398,7 +428,11 @@
 
 static int xmp_removexattr(const char *path, const char *name)
 {
+#if (__FreeBSD__ >= 10)
+    int res = removexattr(path, name, 0);
+#else
     int res = lremovexattr(path, name);
+#endif
     if (res == -1)
         return -errno;
     return 0;
@@ -414,7 +448,20 @@
                        sizeof(fi->lock_owner));
 }
 
+void *
+xmp_init(struct fuse_conn_info *conn)
+{
+    return NULL;
+}
+
+void
+xmp_destroy(void *userdata)
+{
+}
+
 static struct fuse_operations xmp_oper = {
+    .init       = xmp_init,
+    .destroy    = xmp_destroy,
     .getattr	= xmp_getattr,
     .fgetattr	= xmp_fgetattr,
     .access	= xmp_access,
diff -Naur old/fuse.pc.in new/fuse.pc.in
--- old/fuse.pc.in	2006-12-09 10:52:22.000000000 -0800
+++ new/fuse.pc.in	2007-06-05 16:46:06.000000000 -0700
@@ -4,7 +4,7 @@
 includedir=@includedir@
 
 Name: fuse
-Description: Filesystem in Userspace
+Description: File System in User Space (MacFUSE)
 Version: @VERSION@
 Libs: -L${libdir} -lfuse @libfuse_libs@
-Cflags: -I${includedir}/fuse -D_FILE_OFFSET_BITS=64
+Cflags: -I${includedir}/fuse -D__FreeBSD__=10 -D_FILE_OFFSET_BITS=64
diff -Naur old/lib/Makefile.in new/lib/Makefile.in
--- old/lib/Makefile.in	2007-04-29 02:13:27.000000000 -0700
+++ new/lib/Makefile.in	2007-06-05 16:46:06.000000000 -0700
@@ -60,8 +60,12 @@
 	fuse_loop.c fuse_loop_mt.c fuse_lowlevel.c fuse_misc.h \
 	fuse_mt.c fuse_opt.c fuse_session.c fuse_signals.c helper.c \
 	mount.c mount_bsd.c
+ifeq (@host_vendor@, apple)
+am__objects_1 = mount_bsd.lo
+else
 @BSD_FALSE@am__objects_1 = mount.lo
 @BSD_TRUE@am__objects_1 = mount_bsd.lo
+endif
 am_libfuse_la_OBJECTS = fuse.lo fuse_kern_chan.lo fuse_loop.lo \
 	fuse_loop_mt.lo fuse_lowlevel.lo fuse_mt.lo fuse_opt.lo \
 	fuse_session.lo fuse_signals.lo helper.lo $(am__objects_1)
@@ -202,8 +206,12 @@
  -D_FILE_OFFSET_BITS=64 -D_REENTRANT -DFUSE_USE_VERSION=26
 
 lib_LTLIBRARIES = libfuse.la libulockmgr.la
+ifeq (@host_vendor@, apple)
+mount_source = mount_bsd.c
+else
 @BSD_FALSE@mount_source = mount.c
 @BSD_TRUE@mount_source = mount_bsd.c
+endif
 libfuse_la_SOURCES = \
 	fuse.c			\
 	fuse_i.h		\
@@ -219,8 +227,12 @@
 	helper.c		\
 	$(mount_source)
 
+ifeq ($(host_vendor), apple)
+libfuse_la_LDFLAGS = @libfuse_libs@
+else
 libfuse_la_LDFLAGS = @libfuse_libs@ -version-number 2:6:5 \
 	-Wl,--version-script,$(srcdir)/fuse_versionscript
+endif
 
 libulockmgr_la_SOURCES = ulockmgr.c
 libulockmgr_la_LDFLAGS = -version-number 1:0:1
diff -Naur old/lib/fuse.c new/lib/fuse.c
--- old/lib/fuse.c	2007-02-02 03:57:48.000000000 -0800
+++ new/lib/fuse.c	2007-06-05 16:46:06.000000000 -0700
@@ -57,6 +57,11 @@
     int auto_cache;
     int intr;
     int intr_signal;
+#if (__FreeBSD__ >= 10)
+    char *volicon;
+    char *volicon_data;
+    off_t volicon_size;
+#endif
 };
 
 struct fuse {
@@ -136,6 +141,249 @@
                                struct fuse_file_info *);
 static int fuse_compat_statfs(struct fuse *, fuse_req_t, struct statvfs *);
 
+#if (__FreeBSD__ >= 10)
+
+/* volicon stuff */
+
+#define VOLICON_PATH    "/.VolumeIcon.icns"
+#define VOLICON_MAXSIZE (1024 * 1024)
+
+static __inline__ int
+volicon_is_the_file(struct fuse *f, const char *path)
+{
+    return (f->conf.volicon && (!strcmp(path, VOLICON_PATH)));
+}
+
+static __inline__ int
+volicon_backend_do_getattr(struct fuse *f, const char *path, struct stat *buf)
+{
+    int res = 0;
+
+    if (volicon_is_the_file(f, path)) {
+        memset((void *)buf, 0, sizeof(struct stat));
+        buf->st_mode = S_IFREG | 0444;
+        buf->st_nlink = 1;
+        buf->st_uid = buf->st_gid = 0;
+        buf->st_size = f->conf.volicon_size;
+        buf->st_atime = buf->st_ctime = buf->st_mtime = time(NULL);
+    } else {
+        res = f->op.getattr(path, buf);
+    }
+
+    return res;
+}
+
+static __inline__ int
+volicon_backend_do_fgetattr(struct fuse *f, const char *path, struct stat *buf,
+                            struct fuse_file_info *fi)
+{
+    int res = 0;
+
+    if (volicon_is_the_file(f, path)) {
+        memset((void *)buf, 0, sizeof(struct stat));
+        buf->st_mode = S_IFREG | 0444;
+        buf->st_nlink = 1;
+        buf->st_uid = buf->st_gid = 0;
+        buf->st_size = f->conf.volicon_size;
+        buf->st_atime = buf->st_ctime = buf->st_mtime = time(NULL);
+    } else {
+        res = f->op.fgetattr(path, buf, fi);
+    }
+
+    return res;
+}
+
+static __inline__ int
+volicon_backend_do_open(struct fuse *f, const char *path,
+                        struct fuse_file_info *fi)
+{
+    if (volicon_is_the_file(f, path)) {
+        if (fi && ((fi->flags & O_ACCMODE) != O_RDONLY)) {
+            return -EPERM;
+        }
+        return 0;
+    }
+
+    return f->op.open(path, fi);
+}
+
+static __inline__ int
+volicon_backend_read(struct fuse *f, const char *path, char *buf,
+                     size_t size, off_t off, struct fuse_file_info *fi)
+{
+    int res = 0;
+
+    if (volicon_is_the_file(f, path)) {
+        size_t a_size = size;
+        if (off < f->conf.volicon_size) {
+            if ((off + size) > f->conf.volicon_size) {
+                a_size = f->conf.volicon_size - off;
+            }
+            memcpy(buf, (char *)(f->conf.volicon_data) + off, a_size);
+            res = a_size;
+        }
+    } else {
+        res = f->op.read(path, buf, size, off, fi);
+    }
+
+    return res;
+}
+
+/*
+ * We shouldn't need volicon backends for ftruncate() or write() because
+ * we don't allow a writable file descriptor to be obtained in the first
+ * place.
+ */
+
+#include <libgen.h>
+
+#ifdef _POSIX_C_SOURCE
+typedef unsigned char  u_char;
+typedef unsigned short u_short;
+typedef unsigned long  u_long;
+typedef unsigned int   u_int;
+#endif
+#include <sys/attr.h>
+
+#include <sys/vnode.h>
+
+static int FinderInfoGet(const char *path, uint32_t *type, uint32_t *creator);
+typedef struct attrlist attrlist_t;
+
+struct FinderInfoAttrBuf {
+    unsigned long length;
+    fsobj_type_t  objType;
+    char          finderInfo[32];
+};
+typedef struct FinderInfoAttrBuf FinderInfoAttrBuf;
+
+static int
+FinderInfoGet(const char *path, uint32_t *type, uint32_t *creator)
+{
+    int               ret;
+    attrlist_t        attrList;
+    FinderInfoAttrBuf attrBuf;
+
+    if (!type || !creator) {
+        return EINVAL;
+    }
+
+    *type = 0;
+    *creator = 0;
+
+    memset(&attrList, 0, sizeof(attrList));
+    attrList.bitmapcount = ATTR_BIT_MAP_COUNT;
+    attrList.commonattr  = ATTR_CMN_OBJTYPE | ATTR_CMN_FNDRINFO;
+
+    ret = getattrlist(path, &attrList, &attrBuf, sizeof(attrBuf), 0);
+    if (ret != 0) {
+        return errno;
+    }
+
+    if ((ret == 0) && (attrBuf.objType != VREG) ) {
+        return EINVAL;
+    } else {
+        memcpy(type, &attrBuf.finderInfo[0], sizeof(uint32_t));
+        memcpy(creator, &attrBuf.finderInfo[4], sizeof(uint32_t));
+    }
+
+    *type = ntohl(*type);
+    *creator = ntohl(*creator);
+
+    return 0;
+}
+
+static int
+volicon_init(struct fuse *f)
+{
+    int ret;
+    int voliconfd;
+    struct stat sb;
+
+    if (!f->conf.volicon) {
+        return 0;
+    }
+
+    voliconfd = open(f->conf.volicon, O_RDONLY);
+    if (voliconfd < 0) {
+        fprintf(stderr, "failed to access volume icon file (%d)\n", errno);
+        return -1;
+    }
+
+    ret = fstat(voliconfd, &sb);
+    if (ret) {
+        fprintf(stderr, "failed to stat volume icon file (%d)\n", errno);
+        close(voliconfd);
+        return -1;
+    }
+
+    if (sb.st_size > (VOLICON_MAXSIZE)) {
+        fprintf(stderr, "size limit exceeded for volume icon file\n");
+        close(voliconfd);
+        return -1;
+    }
+
+    f->conf.volicon_data = malloc(sb.st_size);
+    if (!f->conf.volicon_data) {
+        fprintf(stderr, "failed to allocate memory for volume icon data\n");
+        close(voliconfd);
+        return -1;
+    }
+
+    ret = read(voliconfd, f->conf.volicon_data, sb.st_size);
+    if (ret != sb.st_size) {
+        fprintf(stderr, "failed to read data from volume icon file\n");
+        close(voliconfd);
+        free(f->conf.volicon_data);
+        return -1;
+    }
+
+    close(voliconfd);
+
+    f->conf.volicon_size = sb.st_size;
+
+    return 0;
+}
+
+void
+volicon_fini(struct fuse *f, const char *mntpath)
+{
+    int ret;
+    size_t len;
+    char *p1, *p2;
+    char dot_path[MAXPATHLEN + 1];
+    uint32_t type, creator;
+
+    if (!f->conf.volicon) {
+        return;
+    }
+
+    len = strlen(mntpath) + 2;
+    p1 = dirname(mntpath);
+    p2 = basename(mntpath);
+    if (!p1 || !p2 || (len > MAXPATHLEN)) {
+        return;
+    }
+
+    ret = snprintf(dot_path, MAXPATHLEN + 1, "%s/._%s", p1, p2);
+    if (ret != len) {
+        return;
+    }
+
+    ret = FinderInfoGet(dot_path, &type, &creator);
+    if (ret) {
+        return;
+    }
+
+    if ((creator == 'FUSE') && (type == 'ROOT')) {
+        (void)unlink(dot_path);
+    }
+
+    return;
+}
+
+#endif
+
 static struct node *get_node_nocheck(struct fuse *f, fuse_ino_t nodeid)
 {
     size_t hash = nodeid % f->id_table_size;
@@ -516,7 +764,11 @@
     int res;
     struct fuse_intr_data d;
     fuse_prepare_interrupt(f, req, &d);
+#if (__FreeBSD__ >= 10)
+    res = volicon_backend_do_getattr(f, path, buf);
+#else
     res = f->op.getattr(path, buf);
+#endif
     fuse_finish_interrupt(f, req, &d);
     return res;
 }
@@ -527,7 +779,11 @@
     int res;
     struct fuse_intr_data d;
     fuse_prepare_interrupt(f, req, &d);
+#if (__FreeBSD__ >= 10)
+    res = volicon_backend_do_fgetattr(f, path, buf, fi);
+#else
     res = f->op.fgetattr(path, buf, fi);
+#endif
     fuse_finish_interrupt(f, req, &d);
     return res;
 }
@@ -558,6 +814,9 @@
 {
     struct fuse_intr_data d;
     fuse_prepare_interrupt(f, req, &d);
+#if (__FreeBSD__ >= 10)
+    if (!volicon_is_the_file(f, path))
+#endif
     f->op.release(path, fi);
     fuse_finish_interrupt(f, req, &d);
 }
@@ -579,7 +838,11 @@
     int res;
     struct fuse_intr_data d;
     fuse_prepare_interrupt(f, req, &d);
+#if (__FreeBSD__ >= 10)
+    res = volicon_backend_do_open(f, path, fi);
+#else
     res = f->op.open(path, fi);
+#endif
     fuse_finish_interrupt(f, req, &d);
     return res;
 }
@@ -590,6 +853,11 @@
     int res;
     struct fuse_intr_data d;
     fuse_prepare_interrupt(f, req, &d);
+#if (__FreeBSD__ >= 10)
+    if (volicon_is_the_file(f, path))
+        res = 0;
+    else
+#endif
     res = f->op.flush(path, fi);
     fuse_finish_interrupt(f, req, &d);
     return res;
@@ -734,6 +1002,16 @@
 
 static void curr_time(struct timespec *now)
 {
+#if (__FreeBSD__ >= 10)
+#define MACFUSE_TIMEVAL_TO_TIMESPEC(tv, ts) {                           \
+        (ts)->tv_sec = (tv)->tv_sec;                                    \
+        (ts)->tv_nsec = (tv)->tv_usec * 1000;                           \
+    }
+    struct timeval tp;
+    gettimeofday(&tp, NULL);
+    /* XXX: TBD: We are losing resolution here. */
+    MACFUSE_TIMEVAL_TO_TIMESPEC(&tp, now);
+#else
     static clockid_t clockid = CLOCK_MONOTONIC;
     int res = clock_gettime(clockid, now);
     if (res == -1 && errno == EINVAL) {
@@ -744,6 +1022,7 @@
         perror("fuse: clock_gettime");
         abort();
     }
+#endif
 }
 
 static void update_stat(struct node *node, const struct stat *stbuf)
@@ -1121,6 +1400,11 @@
         if (f->op.access) {
             struct fuse_intr_data d;
             fuse_prepare_interrupt(f, req, &d);
+#if (__FreeBSD__ >= 10)
+            if (volicon_is_the_file(f, path))
+                err = 0;
+            else
+#endif
             err = f->op.access(path, mask);
             fuse_finish_interrupt(f, req, &d);
         }
@@ -1247,6 +1531,11 @@
         }
         err = -ENOSYS;
         if (f->op.unlink) {
+#if (__FreeBSD__ >= 10)
+            if (volicon_is_the_file(f, path))
+                err = -EPERM;
+            else
+#endif
             if (!f->conf.hard_remove && is_open(f, parent, name))
                 err = hide_node(f, req, path, parent, name);
             else {
@@ -1578,7 +1867,11 @@
         if (f->op.read) {
             struct fuse_intr_data d;
             fuse_prepare_interrupt(f, req, &d);
+#if (__FreeBSD__ >= 10)
+            res = volicon_backend_read(f, path, buf, size, off, fi);
+#else
             res = f->op.read(path, buf, size, off, fi);
+#endif
             fuse_finish_interrupt(f, req, &d);
         }
         free(path);
@@ -1703,6 +1996,11 @@
         if (f->op.fsync) {
             struct fuse_intr_data d;
             fuse_prepare_interrupt(f, req, &d);
+#if (__FreeBSD__ >= 10)
+            if (volicon_is_the_file(f, path))
+                err = 0;
+            else
+#endif
             err = f->op.fsync(path, datasync, fi);
             fuse_finish_interrupt(f, req, &d);
         }
@@ -2573,6 +2871,9 @@
     FUSE_LIB_OPT("negative_timeout=%lf",  negative_timeout, 0),
     FUSE_LIB_OPT("intr",                  intr, 1),
     FUSE_LIB_OPT("intr_signal=%d",        intr_signal, 0),
+#if (__FreeBSD__ >= 10)
+    FUSE_LIB_OPT("volicon=%s",            volicon, 0),
+#endif
     FUSE_OPT_END
 };
 
@@ -2594,6 +2895,9 @@
 "    -o ac_attr_timeout=T   auto cache timeout for attributes (attr_timeout)\n"
 "    -o intr                allow requests to be interrupted\n"
 "    -o intr_signal=NUM     signal to send on interrupt (%i)\n"
+#if (__FreeBSD__ >= 10)
+"    -o volicon=PATH        path to icon file for the volume\n"
+#endif
 "\n", FUSE_DEFAULT_INTR_SIGNAL);
 }
 
@@ -2676,10 +2980,21 @@
     f->conf.attr_timeout = 1.0;
     f->conf.negative_timeout = 0.0;
     f->conf.intr_signal = FUSE_DEFAULT_INTR_SIGNAL;
+#if (__FreeBSD__ >= 10)
+    f->conf.volicon = NULL;
+    f->conf.volicon_data = NULL;
+    f->conf.volicon_size = 0;
+#endif
 
     if (fuse_opt_parse(args, &f->conf, fuse_lib_opts, fuse_lib_opt_proc) == -1)
             goto out_free;
 
+#if (__FreeBSD__ >= 10)
+    if (volicon_init(f) != 0) {
+        goto out_free;
+    }
+#endif
+
     if (!f->conf.ac_attr_timeout_set)
         f->conf.ac_attr_timeout = f->conf.attr_timeout;
 
@@ -2994,12 +3309,14 @@
                                   sizeof(struct fuse_operations_compat1), 11);
 }
 
+#if !(__FreeBSD__ >= 10)
 __asm__(".symver fuse_exited,__fuse_exited@");
 __asm__(".symver fuse_process_cmd,__fuse_process_cmd@");
 __asm__(".symver fuse_read_cmd,__fuse_read_cmd@");
 __asm__(".symver fuse_set_getcontext_func,__fuse_set_getcontext_func@");
 __asm__(".symver fuse_new_compat2,fuse_new@");
 __asm__(".symver fuse_new_compat22,fuse_new@FUSE_2.2");
+#endif
 
 #else /* __FreeBSD__ */
 
@@ -3036,4 +3353,6 @@
                                     op_size, 25);
 }
 
+#if !(__FreeBSD__ >= 10)
 __asm__(".symver fuse_new_compat25,fuse_new@FUSE_2.5");
+#endif
diff -Naur old/lib/fuse_lowlevel.c new/lib/fuse_lowlevel.c
--- old/lib/fuse_lowlevel.c	2006-12-09 10:52:22.000000000 -0800
+++ new/lib/fuse_lowlevel.c	2007-06-05 16:46:06.000000000 -0700
@@ -1395,9 +1395,11 @@
     return 0;
 }
 
+#if !(__FreeBSD__ >= 10)
 __asm__(".symver fuse_reply_statfs_compat,fuse_reply_statfs@FUSE_2.4");
 __asm__(".symver fuse_reply_open_compat,fuse_reply_open@FUSE_2.4");
 __asm__(".symver fuse_lowlevel_new_compat,fuse_lowlevel_new@FUSE_2.4");
+#endif
 
 #else /* __FreeBSD__ */
 
@@ -1421,4 +1423,6 @@
                                     op_size, userdata);
 }
 
+#if !(__FreeBSD__ >= 10)
 __asm__(".symver fuse_lowlevel_new_compat25,fuse_lowlevel_new@FUSE_2.5");
+#endif
diff -Naur old/lib/fuse_mt.c new/lib/fuse_mt.c
--- old/lib/fuse_mt.c	2006-12-09 10:51:14.000000000 -0800
+++ new/lib/fuse_mt.c	2007-06-05 16:46:06.000000000 -0700
@@ -120,4 +120,6 @@
     return fuse_session_loop_mt(fuse_get_session(f));
 }
 
+#if !(__FreeBSD__ >= 10)
 __asm__(".symver fuse_loop_mt_proc,__fuse_loop_mt@");
+#endif
diff -Naur old/lib/fuse_session.c new/lib/fuse_session.c
--- old/lib/fuse_session.c	2006-12-09 10:51:14.000000000 -0800
+++ new/lib/fuse_session.c	2007-06-05 16:46:06.000000000 -0700
@@ -15,6 +15,9 @@
 #include <string.h>
 #include <assert.h>
 #include <errno.h>
+#if (__FreeBSD__ >= 10)
+#include <sys/param.h>
+#endif
 
 struct fuse_session {
     struct fuse_session_ops op;
@@ -24,6 +27,10 @@
     volatile int exited;
 
     struct fuse_chan *ch;
+
+#if (__FreeBSD__ >= 10)
+    char mntonname[MAXPATHLEN];
+#endif
 };
 
 struct fuse_chan {
@@ -40,6 +47,30 @@
     int compat;
 };
 
+#if (__FreeBSD__ >= 10)
+char *fuse_session_get_mntonname(struct fuse_session *se)
+{
+    if (se) {
+        return se->mntonname;
+    }
+
+    return NULL;
+}
+
+void fuse_session_set_mntonname(struct fuse_session *se, char *mntonname)
+{
+    if (!se || !mntonname) {
+        return;
+    }
+
+    if (!realpath(mntonname, se->mntonname)) {
+        memset(se->mntonname, 0, MAXPATHLEN);
+    }
+
+    return;
+}
+#endif
+
 struct fuse_session *fuse_session_new(struct fuse_session_ops *op, void *data)
 {
     struct fuse_session *se = (struct fuse_session *) malloc(sizeof(*se));
diff -Naur old/lib/fuse_signals.c new/lib/fuse_signals.c
--- old/lib/fuse_signals.c	2006-12-09 10:51:14.000000000 -0800
+++ new/lib/fuse_signals.c	2007-06-05 16:46:06.000000000 -0700
@@ -13,12 +13,34 @@
 #include <signal.h>
 
 static struct fuse_session *fuse_instance;
+#if (__FreeBSD__ >= 10)
+extern char *fuse_session_get_mntonname(struct fuse_session *se);
+
+#include <unistd.h>
+#endif
 
 static void exit_handler(int sig)
 {
     (void) sig;
+#if (__FreeBSD__ >= 10)
+    if (fuse_instance && !fuse_session_exited(fuse_instance)) {
+        int fd;
+        pid_t pid;
+
+        fd = fuse_chan_fd(fuse_session_next_chan(fuse_instance, NULL));
+        pid = fork();
+        if (pid == 0) { /* child */
+             char *mntonname = fuse_session_get_mntonname(fuse_instance);
+             fcntl(fd, F_SETFD, 1); /* close-on-exec */
+             execl("/sbin/umount", "/sbin/umount", mntonname, NULL);
+        } else {
+            /* We do nothing in the parent. */
+        }
+    }
+#else
     if (fuse_instance)
         fuse_session_exit(fuse_instance);
+#endif
 }
 
 static int set_one_signal_handler(int sig, void (*handler)(int))
diff -Naur old/lib/helper.c new/lib/helper.c
--- old/lib/helper.c	2006-12-09 10:52:22.000000000 -0800
+++ new/lib/helper.c	2007-06-05 16:46:06.000000000 -0700
@@ -264,6 +264,10 @@
     if (fd)
         *fd = fuse_chan_fd(ch);
 
+#if (__FreeBSD__ >= 10)
+    fuse_session_set_mntonname(fuse_get_session(fuse), *mountpoint);
+#endif
+
     return fuse;
 
  err_unmount:
@@ -286,6 +290,12 @@
 static void fuse_teardown_common(struct fuse *fuse, char *mountpoint)
 {
     struct fuse_session *se = fuse_get_session(fuse);
+#if (__FreeBSD__ >= 10)
+    const char *mntonname = (const char *)fuse_session_get_mntonname(se);
+    if (mntonname) {
+        volicon_fini(fuse, mntonname);
+    }
+#endif 
     struct fuse_chan *ch = fuse_session_next_chan(se, NULL);
     fuse_remove_signal_handlers(se);
     fuse_unmount_common(mountpoint, ch);
@@ -390,11 +400,13 @@
     return fuse_mount_compat22(mountpoint, NULL);
 }
 
+#if !(__FreeBSD__ >= 10)
 __asm__(".symver fuse_setup_compat2,__fuse_setup@");
 __asm__(".symver fuse_setup_compat22,fuse_setup@FUSE_2.2");
 __asm__(".symver fuse_teardown,__fuse_teardown@");
 __asm__(".symver fuse_main_compat2,fuse_main@");
 __asm__(".symver fuse_main_real_compat22,fuse_main_real@FUSE_2.2");
+#endif
 
 #endif /* __FreeBSD__ */
 
@@ -427,7 +439,9 @@
     return fuse_kern_mount(mountpoint, args);
 }
 
+#if !(__FreeBSD__ >= 10)
 __asm__(".symver fuse_setup_compat25,fuse_setup@FUSE_2.5");
 __asm__(".symver fuse_teardown_compat22,fuse_teardown@FUSE_2.2");
 __asm__(".symver fuse_main_real_compat25,fuse_main_real@FUSE_2.5");
 __asm__(".symver fuse_mount_compat25,fuse_mount@FUSE_2.5");
+#endif
diff -Naur old/lib/mount.c new/lib/mount.c
--- old/lib/mount.c	2007-01-02 09:10:33.000000000 -0800
+++ new/lib/mount.c	2007-06-05 16:46:06.000000000 -0700
@@ -304,5 +304,7 @@
     return res;
 }
 
+#if !(__FreeBSD__ >= 10)
 __asm__(".symver fuse_mount_compat22,fuse_mount@FUSE_2.2");
 __asm__(".symver fuse_unmount_compat22,fuse_unmount@FUSE_2.2");
+#endif
diff -Naur old/lib/mount_bsd.c new/lib/mount_bsd.c
--- old/lib/mount_bsd.c	2006-12-09 10:51:14.000000000 -0800
+++ new/lib/mount_bsd.c	2007-06-05 16:46:53.000000000 -0700
@@ -6,6 +6,12 @@
     See the file COPYING.LIB.
 */
 
+#if (__FreeBSD__ >= 10)
+#undef _POSIX_C_SOURCE
+#include <sys/types.h>
+#include <CoreFoundation/CoreFoundation.h>
+#endif
+
 #include "fuse_i.h"
 #include "fuse_opt.h"
 
@@ -21,8 +27,75 @@
 #include <string.h>
 #include <paths.h>
 
+#if (__FreeBSD__ >= 10)
+#define FUSERMOUNT_PROG  "/System/Library/Filesystems/fusefs.fs/Support/mount_fusefs"
+#define FUSE_DEV_TRUNK   "/dev/fuse"
+#define PRIVATE_LOAD_COMMAND "/System/Library/Filesystems/fusefs.fs/Support/load_fusefs"
+
+#include <sys/param.h>
+#include <sys/mount.h>
+#include <AssertMacros.h>
+
+static const char *MacFUSE = "MacFUSE version 0.5.0, " __DATE__ ", " __TIME__;
+
+__unused static int
+checkloadable_unused(void)
+{
+    int ret;
+    struct vfsconf vfc;
+    
+    ret = getvfsbyname("fusefs", &vfc);
+    
+    return ret;
+}   
+
+static int
+checkloadable(void)
+{
+    return 1; /* load_fusefs will take care of checking */
+}
+
+int
+loadkmod()
+{
+    int result = -1;
+    int pid, terminated_pid;
+    union wait status;
+
+    pid = fork();
+
+    if (pid == 0) {
+        result = execl(PRIVATE_LOAD_COMMAND, PRIVATE_LOAD_COMMAND, NULL);
+        
+        /* exec failed */
+        goto Return;
+    }
+
+    require_action(pid != -1, Return, result = errno);
+
+    while ((terminated_pid = wait4(pid, (int *)&status, 0, NULL)) < 0) {
+        /* retry if EINTR, else break out with error */
+        if (errno != EINTR) {
+            break;
+        }
+    }
+
+    if ((terminated_pid == pid) && (WIFEXITED(status))) {
+        result = WEXITSTATUS(status);
+    } else {
+        result = -1;
+    }
+
+Return:
+    check_noerr_string(result, strerror(errno));
+    
+    return result;
+}
+
+#else
 #define FUSERMOUNT_PROG         "mount_fusefs"
 #define FUSE_DEV_TRUNK          "/dev/fuse"
+#endif
 
 enum {
     KEY_ALLOW_ROOT,
@@ -30,6 +103,10 @@
     KEY_HELP,
     KEY_VERSION,
     KEY_KERN
+#if (__FreeBSD__ >= 10)
+    ,
+    KEY_ICON,
+#endif
 };
 
 struct mount_opts {
@@ -108,11 +185,44 @@
     FUSE_OPT_KEY("noprivate",           KEY_KERN),
     FUSE_OPT_KEY("noneglect_shares",    KEY_KERN),
     FUSE_OPT_KEY("nopush_symlinks_in",  KEY_KERN),
+#if (__FreeBSD__ >= 10)
+    /* Mac OS X options */
+    FUSE_OPT_KEY("allow_recursion",     KEY_KERN),
+    FUSE_OPT_KEY("allow_root",          KEY_KERN), /* need to pass this on */
+    FUSE_OPT_KEY("blocksize=",          KEY_KERN),
+    FUSE_OPT_KEY("daemon_timeout=",     KEY_KERN),
+    FUSE_OPT_KEY("defer_auth",          KEY_KERN),
+    FUSE_OPT_KEY("extended_security",   KEY_KERN),
+    FUSE_OPT_KEY("fsid=",               KEY_KERN),
+    FUSE_OPT_KEY("fsname=",             KEY_KERN),
+    FUSE_OPT_KEY("init_timeout=",       KEY_KERN),
+    FUSE_OPT_KEY("iosize=",             KEY_KERN),
+    FUSE_OPT_KEY("jail_symlinks",       KEY_KERN),
+    FUSE_OPT_KEY("kill_on_unmount",     KEY_KERN),
+    FUSE_OPT_KEY("noalerts",            KEY_KERN),
+    FUSE_OPT_KEY("noapplespecial",      KEY_KERN),
+    FUSE_OPT_KEY("noattrcache",         KEY_KERN),
+    FUSE_OPT_KEY("noauthopaque",        KEY_KERN),
+    FUSE_OPT_KEY("noauthopaqueaccess",  KEY_KERN),
+    FUSE_OPT_KEY("nobrowse",            KEY_KERN),
+    FUSE_OPT_KEY("nolocalcaches",       KEY_KERN),
+    FUSE_OPT_KEY("noping_diskarb",      KEY_KERN),
+    FUSE_OPT_KEY("noreadahead",         KEY_KERN),
+    FUSE_OPT_KEY("nosynconclose",       KEY_KERN),
+    FUSE_OPT_KEY("nosyncwrites",        KEY_KERN),
+    FUSE_OPT_KEY("noubc",               KEY_KERN),
+    FUSE_OPT_KEY("novncache",           KEY_KERN),
+    FUSE_OPT_KEY("ping_diskarb",        KEY_KERN),
+    FUSE_OPT_KEY("subtype=",            KEY_KERN),
+    FUSE_OPT_KEY("volicon=",            KEY_ICON),
+    FUSE_OPT_KEY("volname=",            KEY_KERN),
+#else
     /* Linux specific mount options, but let just the mount util handle them */
     FUSE_OPT_KEY("fsname=",             KEY_KERN),
     FUSE_OPT_KEY("nonempty",            KEY_KERN),
     FUSE_OPT_KEY("large_read",          KEY_KERN),
     FUSE_OPT_KEY("max_read=",           KEY_KERN),
+#endif
     FUSE_OPT_END
 };
 
@@ -149,6 +259,15 @@
     case KEY_KERN:
         return fuse_opt_add_opt(&mo->kernel_opts, arg);
 
+#if (__FreeBSD__ >= 10)
+    case KEY_ICON:
+          if (fuse_opt_add_opt(&mo->kernel_opts, "volicon") == -1 ||
+              (fuse_opt_add_arg(outargs, "-o") == -1) ||
+              (fuse_opt_add_arg(outargs, arg) == -1))
+            return -1;
+        return 0;
+#endif
+
     case KEY_HELP:
         mount_help();
         mo->ishelp = 1;
@@ -199,8 +318,21 @@
     if (rv)
         return;
 
+#if (__FreeBSD__ >= 10)
+    {
+        int ret;
+        char *rp = NULL;
+        char resolved_path[PATH_MAX];
+
+        rp = realpath(mountpoint, resolved_path);
+        if (rp) {
+            ret = unmount(resolved_path, 0);
+        }
+    }
+#else
     asprintf(&umount_cmd, "/sbin/umount %s", dev);
     system(umount_cmd);
+#endif
 }
 
 void fuse_kern_unmount(const char *mountpoint, int fd)
@@ -222,13 +354,29 @@
     if (*ep != '\0')
         return;
 
+#if (__FreeBSD__ >= 10)
+    {
+        int ret;
+        char *rp = NULL;
+        char resolved_path[PATH_MAX];
+
+        rp = realpath(mountpoint, resolved_path);
+        if (rp) {
+            ret = unmount(resolved_path, 0);
+        }
+    }
+#else
     asprintf(&umount_cmd, "/sbin/umount " _PATH_DEV "%s", dev);
     system(umount_cmd);
+#endif
 }
 
 /* Check if kernel is doing init in background */
 static int init_backgrounded(void)
 {
+#if (__FreeBSD__ >= 10)
+    return 0;
+#else
     int ibg, len;
 
     len = sizeof(ibg);
@@ -237,6 +385,7 @@
         return 0;
 
     return ibg;
+#endif
 }
 
 
@@ -247,6 +396,35 @@
     char *fdnam, *dev;
     int pid;
 
+#if (__FreeBSD__ >= 10)
+    if (!mountpoint) {
+        fprintf(stderr, "missing or invalid mount point\n");
+        return -1;
+    }
+
+    if (checkloadable()) {
+        int result = loadkmod();
+        if (result) {
+            if (result == EBUSY) {
+                CFOptionFlags responseFlags;
+                CFUserNotificationDisplayNotice(
+                    (CFTimeInterval)0,
+                    kCFUserNotificationCautionAlertLevel,
+                    (CFURLRef)0,
+                    (CFURLRef)0,
+                    (CFURLRef)0,
+                    CFSTR("MacFUSE Version Mismatch"),
+                    CFSTR("MacFUSE has been updated but an incompatible or old version of the MacFUSE kernel extension is already loaded. It failed to unload, possibly because a MacFUSE volume is currently mounted.\n\nPlease eject all MacFUSE volumes and try again, or simply restart the system for changes to take effect."),
+                    CFSTR("OK")
+                );
+            }
+            fprintf(stderr, "fusefs file system is not available (%d)\n",
+                    result);
+            return -1;
+        }
+    }
+#endif
+
     fdnam = getenv("FUSE_DEV_FD");
 
     if (fdnam) {
@@ -267,12 +445,29 @@
 
     dev = getenv("FUSE_DEV_NAME");
 
-    if (! dev)
-	dev = FUSE_DEV_TRUNK;
-
-    if ((fd = open(dev, O_RDWR)) < 0) {
-        perror("fuse: failed to open fuse device");
-        return -1;
+    if (dev) {
+        if ((fd = open(dev, O_RDWR)) < 0) {
+            perror("fuse: failed to open fuse device");
+            return -1;
+        }
+    } else {
+#define NFUSEDEVICE 16
+        int r, devidx = -1;
+        char devpath[MAXPATHLEN];
+
+        for (r = 0; r < NFUSEDEVICE; r++) {
+            snprintf(devpath, MAXPATHLEN - 1, "/dev/fuse%d", r);
+            fd = open(devpath, O_RDWR);
+            if (fd >= 0) {
+                dev = devpath;
+                devidx = r;
+                break;
+            }
+        }
+        if (devidx == -1) {
+            perror("fuse: failed to open fuse device");
+            return -1;
+        }
     }
 
 mount:
@@ -322,11 +517,31 @@
             perror("fuse: failed to exec mount program");
             exit(1);
         }
+#if (__FreeBSD__ >= 10)
+        else {
+            int status;
+            waitpid(pid, &status, 0);
+            if (WIFEXITED(status) && (WEXITSTATUS(status) != 0)) {
+                exit(WEXITSTATUS(status));
+            }
+        }
+#endif
 
         exit(0);
     }
 
+#if (__FreeBSD__ >= 10)
+    {
+        int status;
+
+        waitpid(pid, &status, 0);
+        if (WIFEXITED(status) && (WEXITSTATUS(status) != 0)) {
+            exit(WEXITSTATUS(status));
+        }
+    }
+#else
     waitpid(pid, NULL, 0);
+#endif
 
 out:
     return fd;
@@ -360,4 +575,6 @@
     return res;
 }
 
+#if !(__FreeBSD__ >= 10)
 __asm__(".symver fuse_unmount_compat22,fuse_unmount@FUSE_2.2");
+#endif
diff -Naur old/lib/ulockmgr.c new/lib/ulockmgr.c
--- old/lib/ulockmgr.c	2007-01-02 09:10:33.000000000 -0800
+++ new/lib/ulockmgr.c	2007-06-05 16:46:06.000000000 -0700
@@ -18,9 +18,19 @@
 #include <assert.h>
 #include <signal.h>
 #include <sys/stat.h>
+#if (__FreeBSD__ >= 10)
+#undef _POSIX_C_SOURCE
 #include <sys/socket.h>
+#define _POSIX_C_SOURCE 200112L
+#else
+#include <sys/socket.h>
+#endif
 #include <sys/wait.h>
 
+#if (__FreeBSD__ >= 10)
+#define MSG_NOSIGNAL 0
+#endif
+
 struct message {
     unsigned intr : 1;
     unsigned nofd : 1;
@@ -125,6 +135,13 @@
         return -1;
     }
     ulockmgr_cfd = sv[1];
+#if (__FreeBSD__ >= 10)
+    {
+        int on = 1;
+        res = setsockopt(ulockmgr_cfd, SOL_SOCKET, SO_NOSIGPIPE, (void *)&on,
+                         sizeof(on));
+    }
+#endif
     return 0;
 }
 
