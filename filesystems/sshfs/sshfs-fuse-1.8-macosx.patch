diff -Naur old/Makefile.in new/Makefile.in
--- old/Makefile.in	2007-05-16 04:21:20.000000000 -0700
+++ new/Makefile.in	2007-09-16 16:09:44.000000000 -0700
@@ -608,7 +608,11 @@
 @SSH_NODELAY_SO_TRUE@	rm -f "$(DESTDIR)$(libdir)/sshnodelay.so"
 
 @SSH_NODELAY_SO_TRUE@sshnodelay.so:
+ifeq "$(shell uname)" "Darwin"
+@SSH_NODELAY_SO_TRUE@	$(CC) -Wall -dynamiclib $(CFLAGS) $(sshnodelay_libs) -install_name "$(DESTDIR)$(libdir)/sshnodelay.so" sshnodelay.c -o sshnodelay.so
+else
 @SSH_NODELAY_SO_TRUE@	$(CC) -Wall -W -s --shared -fPIC $(sshnodelay_libs) sshnodelay.c -o sshnodelay.so
+endif
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
 .NOEXPORT:
diff -Naur old/README.MacFUSE new/README.MacFUSE
--- old/README.MacFUSE	1969-12-31 16:00:00.000000000 -0800
+++ new/README.MacFUSE	2007-09-16 16:09:44.000000000 -0700
@@ -0,0 +1,9 @@
+MacFUSE Project Page:
+
+http://code.google.com/p/macfuse/
+
+Making a Universal build of sshfs:
+
+0. Make sure dependencies (glib, MacFUSE) are installed
+1. Run ./configure_for_macfuse.sh
+2. Run make
diff -Naur old/cache.c new/cache.c
--- old/cache.c	2007-04-18 13:10:46.000000000 -0700
+++ new/cache.c	2007-09-16 16:09:44.000000000 -0700
@@ -499,6 +499,9 @@
     cache.next_oper = oper;
 
     cache_unity_fill(oper, &cache_oper);
+#if (__FreeBSD__ >= 10)
+    cache_enabled = cache.on;
+#endif
     if (cache.on) {
         cache_oper.getattr  = oper->oper.getattr ? cache_getattr : NULL;
         cache_oper.readlink = oper->oper.readlink ? cache_readlink : NULL;
@@ -552,3 +555,7 @@
 
     return fuse_opt_parse(args, &cache, cache_opts, NULL);
 }
+
+#if (__FreeBSD__ >= 10)
+int cache_enabled;
+#endif
diff -Naur old/cache.h new/cache.h
--- old/cache.h	2006-02-20 03:43:23.000000000 -0800
+++ new/cache.h	2007-09-16 16:09:44.000000000 -0700
@@ -26,3 +26,7 @@
 int cache_parse_options(struct fuse_args *args);
 void cache_add_attr(const char *path, const struct stat *stbuf);
 void cache_invalidate(const char *path);
+
+#if (__FreeBSD__ >= 10)
+extern int cache_enabled;
+#endif
diff -Naur old/configure_for_macfuse.sh new/configure_for_macfuse.sh
--- old/configure_for_macfuse.sh	1969-12-31 16:00:00.000000000 -0800
+++ new/configure_for_macfuse.sh	2007-09-16 16:17:56.000000000 -0700
@@ -0,0 +1,73 @@
+#! /bin/sh
+# Copyright (C) 2006-2007 Amit Singh. All Rights Reserved.
+#
+
+UNAME=/usr/bin/uname
+
+os_name=`$UNAME -s`
+os_codename="Unknown"
+os_release=`$UNAME -r`
+sdk_dir="/dev/null"
+
+current_product=${1:-`pwd`}
+
+if [ "$os_name" != "Darwin" ]
+then
+    echo "This script can only be run on Darwin"
+    exit 1
+fi
+
+case "$os_release" in
+  8*)
+      sdk_dir="/Developer/SDKs/MacOSX10.4u.sdk"
+      os_codename="Tiger"
+  ;;
+  9*)
+      sdk_dir="/Developer/SDKs/MacOSX10.5.sdk"
+      os_codename="Leopard"
+  ;;
+  *)
+      echo "Unsupported Mac OS X release $os_release"
+      exit 1
+  ;;
+esac
+
+case "$current_product" in
+
+  *gettext-*)
+      echo "Configuring Universal build of gettext for MacFUSE"
+      CFLAGS="-O0 -g -D_POSIX_C_SOURCE=200112L -arch i386 -arch ppc -isysroot $sdk_dir" LDFLAGS="-Wl,-syslibroot,$sdk_dir -arch i386 -arch ppc -fno-common" ./configure --prefix=/usr/local --disable-dependency-tracking --with-libiconv-prefix=$sdk_dir/usr
+  ;;
+
+  *glib-*)
+      echo "Configuring Universal build of glib for MacFUSE"
+      CFLAGS="-O0 -g -D_POSIX_C_SOURCE=200112L -arch i386 -arch ppc -isysroot $sdk_dir -I/usr/local/include" LDFLAGS="-Wl,-syslibroot,$sdk_dir -arch i386 -arch ppc -L/usr/local/lib" ./configure --prefix=/usr/local --disable-dependency-tracking --enable-static
+  ;;
+
+  *pkg-config-*) 
+      echo "Configuring Universal build of pkg-config for MacFUSE"
+      if [ "$os_codename" = "Leopard" ]
+      then
+          CFLAGS="-O -g -D_POSIX_C_SOURCE=200112L -arch i386 -arch ppc -isysroot $sdk_dir" LDFLAGS="-arch i386 -arch ppc" ./configure --prefix=/usr/local --disable-dependency-tracking
+      else
+          CFLAGS="-O -g -arch i386 -arch ppc -isysroot $sdk_dir" LDFLAGS="-arch i386 -arch ppc" ./configure --prefix=/usr/local --disable-dependency-tracking
+      fi
+  ;;
+
+  *sshfs*) 
+      echo "Configuring Universal build of sshfs for MacFUSE"
+      if [ "$os_codename" = "Leopard" ]
+      then
+          CFLAGS="-D__FreeBSD__=10 -DSSH_NODELAY_WORKAROUND -D_POSIX_C_SOURCE=200112L -O -g -arch i386 -arch ppc -isysroot /Developer/SDKs/MacOSX10.5.sdk" LDFLAGS="-arch i386 -arch ppc" ./configure --prefix=/usr/local --disable-dependency-tracking
+      else
+          CFLAGS="-D__FreeBSD__=10 -DSSH_NODELAY_WORKAROUND -D_POSIX_C_SOURCE=200112L -O -g -arch i386 -arch ppc -isysroot /Developer/SDKs/MacOSX10.4u.sdk" LDFLAGS="-arch i386 -arch ppc" ./configure --prefix=/usr/local --disable-dependency-tracking
+      fi
+  ;;
+
+  *)
+      echo "Don't know how to configure unrecognized product $current_product"
+      exit 1
+  ;;
+esac
+
+exit $?
diff -Naur old/darwin_compat.h new/darwin_compat.h
--- old/darwin_compat.h	1969-12-31 16:00:00.000000000 -0800
+++ new/darwin_compat.h	2007-09-16 16:10:17.000000000 -0700
@@ -0,0 +1,147 @@
+/*
+ * Copyright (C) 2006,2007 Google. All Rights Reserved.
+ * Amit Singh <singh@>
+ */
+
+#ifndef _DARWIN_COMPAT_H_
+#define _DARWIN_COMPAT_H_
+
+#define MACFUSE_SSHFS_VERSION "1.0.0rc1"
+
+#include <AvailabilityMacros.h>
+
+/* Half-baked makeshift implementation (cancelable). */
+
+#include <errno.h>
+#include <sys/types.h>
+#include <pthread.h>
+    
+typedef struct {
+    int32_t         value;
+    int32_t         wakeups;
+    pthread_mutex_t mutex;
+    pthread_cond_t  cond;
+} fuse_sem_t;
+
+typedef fuse_sem_t sem_t;
+        
+#define SEM_VALUE_DEAD ((int32_t)0xdeadbeef)
+#define SEM_VALUE_MAX  ((int32_t)32767)
+
+/* http://www.opengroup.org/onlinepubs/007908799/xsh/sem_init.html */
+static __inline__
+int
+fuse_sem_init(fuse_sem_t *sem, int pshared, int value)
+{
+
+    if (value > SEM_VALUE_MAX) {
+        errno = EINVAL;
+        return -1;
+    }
+
+    if (pshared) {
+        errno = ENOSYS;
+        return -1;
+    }
+
+    if (!sem) {
+        errno = EINVAL;
+        return -1;
+    }
+
+    sem->value = value;
+    sem->wakeups = 0;
+    pthread_cond_init(&sem->cond, NULL);
+    pthread_mutex_init(&sem->mutex, NULL);
+
+    return 0;
+}
+
+/* http://www.opengroup.org/onlinepubs/007908799/xsh/sem_destroy.html */
+static __inline__
+int
+fuse_sem_destroy(fuse_sem_t *sem)
+{
+    int ret;
+
+    if (!sem) {
+        errno = EINVAL;
+        return -1;
+    }
+
+    ret = pthread_mutex_lock(&sem->mutex);
+    if (ret) {
+        errno = ret;
+        return -1;
+    }
+
+    if (sem->value < 0) {
+        pthread_mutex_unlock(&sem->mutex);
+        errno = EBUSY;
+        return -1;
+    }
+
+    pthread_cond_destroy(&sem->cond);
+
+    sem->value = SEM_VALUE_DEAD;
+
+    pthread_mutex_unlock(&sem->mutex);
+    pthread_mutex_destroy(&sem->mutex);
+
+    return 0;
+}
+
+/* http://www.opengroup.org/onlinepubs/007908799/xsh/sem_wait.html */
+static __inline__
+int
+fuse_sem_wait(fuse_sem_t *sem)
+{
+    if (!sem || (sem->value == SEM_VALUE_DEAD)) {
+        errno = EINVAL;
+        return -1;
+    }
+
+    pthread_mutex_lock(&sem->mutex);
+    sem->value--;
+    if (sem->value < 0) {
+        do {
+            /*
+             * XXX: This is not really supposed to fail except for some EINVALs
+             *      that shouldn't apply here.
+             */
+            (void)pthread_cond_wait(&sem->cond, &sem->mutex);
+        } while (sem->wakeups < 1);
+        sem->wakeups--;
+    }
+    pthread_mutex_unlock(&sem->mutex);
+
+    return 0;
+}
+
+/* http://www.opengroup.org/onlinepubs/007908799/xsh/sem_post.html */
+static __inline__
+int
+fuse_sem_post(fuse_sem_t *sem)
+{
+    if (!sem || (sem->value == SEM_VALUE_DEAD)) {
+        errno = EINVAL;
+        return -1;
+    }
+
+    pthread_mutex_lock(&sem->mutex);
+    sem->value++;
+    if (sem->value <= 0) {
+        sem->wakeups++;
+        (void)pthread_cond_signal(&sem->cond);
+    }
+    pthread_mutex_unlock(&sem->mutex);
+
+    return 0;
+}
+
+#define sem_init(s, a, b) fuse_sem_init(s, a, b)
+#define sem_destroy(s)    fuse_sem_destroy(s)
+#define sem_post(s)       fuse_sem_post(s)
+#define sem_wait(s)       fuse_sem_wait(s)
+
+#endif /* _DARWIN_COMPAT_H_ */
diff -Naur old/sshfs.c new/sshfs.c
--- old/sshfs.c	2007-05-16 04:20:48.000000000 -0700
+++ new/sshfs.c	2007-09-16 16:10:55.000000000 -0700
@@ -18,7 +18,11 @@
 #include <string.h>
 #include <stdint.h>
 #include <errno.h>
+#if !(__FreeBSD__ >= 10)
 #include <semaphore.h>
+#else
+#include "darwin_compat.h"
+#endif
 #include <pthread.h>
 #include <netdb.h>
 #include <signal.h>
@@ -30,6 +34,10 @@
 #include <netinet/in.h>
 #include <netinet/tcp.h>
 #include <glib.h>
+#if (__FreeBSD__ >= 10)
+#include <libgen.h>
+#include <strings.h>
+#endif
 
 #include "cache.h"
 
@@ -100,6 +108,16 @@
 
 #define SSHNODELAY_SO "sshnodelay.so"
 
+#if (__FreeBSD__ >= 10)
+
+#ifndef LIBDIR
+#define LIBDIR "/usr/local/lib"
+#endif
+
+static char sshfs_program_path[PATH_MAX] = { 0 };
+
+#endif
+
 struct buffer {
     uint8_t *p;
     size_t len;
@@ -149,6 +167,9 @@
     int connver;
     int modifver;
     int refs;
+#if (__FreeBSD__ >= 10)
+    pthread_mutex_t file_lock;
+#endif
 };
 
 struct sshfs {
@@ -184,6 +205,10 @@
     int server_version;
     unsigned remote_uid;
     unsigned local_uid;
+#if (__FreeBSD__ >= 10)
+    unsigned remote_gid;
+    unsigned local_gid;
+#endif
     int remote_uid_detected;
     unsigned blksize;
     char *progname;
@@ -585,8 +610,17 @@
         }
     }
 
+#if (__FreeBSD__ >= 10)
+    if (sshfs.remote_uid_detected) {
+        if (uid == sshfs.remote_uid)
+            uid = sshfs.local_uid;
+        if (gid == sshfs.remote_gid)
+            gid = sshfs.local_gid;
+    }
+#else
     if (sshfs.remote_uid_detected && uid == sshfs.remote_uid)
         uid = sshfs.local_uid;
+#endif
 
     memset(stbuf, 0, sizeof(struct stat));
     stbuf->st_mode = mode;
@@ -645,11 +679,33 @@
 #ifdef SSH_NODELAY_WORKAROUND
 static int do_ssh_nodelay_workaround(void)
 {
+#if (__FreeBSD__ >= 10)
+    char *oldpreload = getenv("DYLD_INSERT_LIBRARIES");
+#else
     char *oldpreload = getenv("LD_PRELOAD");
+#endif
     char *newpreload;
     char sopath[PATH_MAX];
     int res;
 
+#if (__FreeBSD__ >= 10)
+    char *sshfs_program_path_base = NULL;
+    if (!sshfs_program_path[0]) {
+        goto nobundle;
+    }
+    sshfs_program_path_base = dirname(sshfs_program_path);
+    if (!sshfs_program_path_base) {
+        goto nobundle;
+    }
+    snprintf(sopath, sizeof(sopath), "%s/%s", sshfs_program_path_base,
+             SSHNODELAY_SO);
+    res = access(sopath, R_OK);
+    if (res == -1) {
+        goto nobundle;
+    }
+    goto pathok;
+nobundle:
+#endif
     snprintf(sopath, sizeof(sopath), "%s/%s", LIBDIR, SSHNODELAY_SO);
     res = access(sopath, R_OK);
     if (res == -1) {
@@ -673,14 +729,22 @@
             return -1;
         }
     }
+#if (__FreeBSD__ >= 10)
+pathok:
+#endif
 
     newpreload = g_strdup_printf("%s%s%s",
                                  oldpreload ? oldpreload : "",
                                  oldpreload ? " " : "",
                                  sopath);
 
+#if (__FreeBSD__ >= 10)
+    if (!newpreload || setenv("DYLD_INSERT_LIBRARIES", newpreload, 1) == -1)
+        fprintf(stderr, "warning: failed set DYLD_INSERT_LIBRARIES for ssh nodelay workaround\n");
+#else
     if (!newpreload || setenv("LD_PRELOAD", newpreload, 1) == -1)
         fprintf(stderr, "warning: failed set LD_PRELOAD for ssh nodelay workaround\n");
+#endif
     g_free(newpreload);
     return 0;
 }
@@ -1154,6 +1218,10 @@
 
     sshfs.remote_uid = stbuf.st_uid;
     sshfs.local_uid = getuid();
+#if (__FreeBSD__ >= 10)
+    sshfs.remote_gid = stbuf.st_gid;
+    sshfs.local_gid = getgid();
+#endif
     sshfs.remote_uid_detected = 1;
     DEBUG("remote_uid = %i\n", sshfs.remote_uid);
 
@@ -1719,6 +1787,14 @@
     buf_init(&buf, 0);
     buf_add_path(&buf, path);
     buf_add_uint32(&buf, SSH_FILEXFER_ATTR_UIDGID);
+#if (__FreeBSD__ >= 10)
+    if (sshfs.remote_uid_detected) {
+        if (uid == sshfs.local_uid)
+            uid = sshfs.remote_uid;
+        if (gid == sshfs.local_gid)
+            gid = sshfs.remote_gid;
+    }
+#endif
     buf_add_uint32(&buf, uid);
     buf_add_uint32(&buf, gid);
     err = sftp_request(SSH_FXP_SETSTAT, &buf, SSH_FXP_STATUS, NULL);
@@ -1800,6 +1876,9 @@
     sf = g_new0(struct sshfs_file, 1);
     list_init(&sf->write_reqs);
     pthread_cond_init(&sf->write_finished, NULL);
+#if (__FreeBSD__ >= 10)
+    pthread_mutex_init(&sf->file_lock, NULL);
+#endif
     /* Assume random read after open */
     sf->is_seq = 0;
     sf->refs = 1;
@@ -1832,11 +1911,21 @@
     }
 
     if (!err) {
+#if (__FreeBSD__ >= 10)
+        if (cache_enabled)
+            cache_add_attr(path, &stbuf);
+#else
         cache_add_attr(path, &stbuf);
+#endif
         buf_finish(&sf->handle);
         fi->fh = (unsigned long) sf;
     } else {
+#if (__FreeBSD__ >= 10)
+        if (cache_enabled)
+            cache_invalidate(path);
+#else
         cache_invalidate(path);
+#endif
         g_free(sf);
     }
     buf_free(&buf);
@@ -1891,14 +1980,32 @@
 
 static void sshfs_file_put(struct sshfs_file *sf)
 {
+#if (__FreeBSD__ >= 10)
+    pthread_mutex_lock(&sf->file_lock);
+#endif
     sf->refs--;
+#if (__FreeBSD__ >= 10)
+    if (!sf->refs) {
+        pthread_mutex_unlock(&sf->file_lock);
+        g_free(sf);
+    } else {
+        pthread_mutex_unlock(&sf->file_lock);
+    }
+#else
     if (!sf->refs)
         g_free(sf);
+#endif
 }
 
 static struct sshfs_file *sshfs_file_get(struct sshfs_file *sf)
 {
+#if (__FreeBSD__ >= 10)
+    pthread_mutex_lock(&sf->file_lock);
+#endif
     sf->refs++;
+#if (__FreeBSD__ >= 10)
+    pthread_mutex_unlock(&sf->file_lock);
+#endif
     return sf;
 }
 
@@ -2533,7 +2640,12 @@
         exit(1);
 
     case KEY_VERSION:
+#if (__FreeBSD__ >= 10)
+        fprintf(stderr, "SSHFS version %s (MacFUSE SSHFS %s)\n",
+                PACKAGE_VERSION, MACFUSE_SSHFS_VERSION);
+#else
         fprintf(stderr, "SSHFS version %s\n", PACKAGE_VERSION);
+#endif
 #if FUSE_VERSION >= 25
         fuse_opt_add_arg(outargs, "--version");
         sshfs_fuse_main(outargs);
@@ -2599,8 +2711,17 @@
         fuse_opt_insert_arg(args, 1, "-olarge_read");
 }
 
+#if (__FreeBSD__ >= 10)
+int main(int argc, char *argv[], __unused char *envp[], char **exec_path)
+#else
 int main(int argc, char *argv[])
+#endif
 {
+#if (__FreeBSD__ >= 10)
+    if (!realpath(*exec_path, sshfs_program_path)) {
+        memset(sshfs_program_path, 0, PATH_MAX);
+    }
+#endif
     int res;
     struct fuse_args args = FUSE_ARGS_INIT(argc, argv);
     char *tmp;
@@ -2608,13 +2729,21 @@
     char *base_path;
     const char *sftp_server;
 
+#if (__FreeBSD__ >= 10)
+    /* Until this gets fixed somewhere else. */
+    g_slice_set_config(G_SLICE_CONFIG_ALWAYS_MALLOC, TRUE);
+#endif
     g_thread_init(NULL);
 
     sshfs.blksize = 4096;
     sshfs.max_read = 65536;
     sshfs.nodelay_workaround = 1;
     sshfs.nodelaysrv_workaround = 0;
+#if (__FreeBSD__ >= 10)
+    sshfs.rename_workaround = 1;
+#else
     sshfs.rename_workaround = 0;
+#endif
     sshfs.truncate_workaround = 0;
     sshfs.buflimit_workaround = 1;
     sshfs.ssh_ver = 2;
@@ -2624,6 +2753,10 @@
     ssh_add_arg("-a");
     ssh_add_arg("-oClearAllForwardings=yes");
 
+#if (__FreeBSD__ >= 10)
+    sshfs.detect_uid = 1;
+#endif
+
     if (fuse_opt_parse(&args, &sshfs, sshfs_opts, sshfs_opt_proc) == -1 ||
         parse_workarounds() == -1)
         exit(1);
diff -Naur old/sshnodelay.c new/sshnodelay.c
--- old/sshnodelay.c	2006-02-01 01:43:22.000000000 -0800
+++ new/sshnodelay.c	2007-09-16 16:09:44.000000000 -0700
@@ -5,6 +5,31 @@
 #include <netinet/in.h>
 #include <netinet/tcp.h>
 
+#if (__FreeBSD__ >= 10)
+
+int custom_connect(int sock, const struct sockaddr *addr, socklen_t addrlen);
+
+typedef struct interpose_s {
+    void *new_func;
+    void *orig_func;
+} interpose_t;
+
+static const interpose_t interposers[] \
+    __attribute__ ((section("__DATA, __interpose"))) = {
+        { (void *)custom_connect,  (void *)connect  },
+    };
+   
+int custom_connect(int sock, const struct sockaddr *addr, socklen_t addrlen)
+{
+    int res = connect(sock, addr, addrlen);
+    if (!res && addr->sa_family == AF_INET) {
+        int opt = 1;
+        setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, &opt, sizeof(opt));
+    }
+    return res;
+}
+
+#else
 int connect(int sock, const struct sockaddr *addr, socklen_t addrlen)
 {
     int (*next_connect)(int, const struct sockaddr *, socklen_t) =
@@ -14,5 +39,5 @@
         int opt = 1;
         setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, &opt, sizeof(opt));
     }
-    return res;
 }
+#endif
