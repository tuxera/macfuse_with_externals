diff -Naur old/README.MacFUSE new/README.MacFUSE
--- old/README.MacFUSE	1969-12-31 16:00:00.000000000 -0800
+++ new/README.MacFUSE	2007-09-16 12:14:59.000000000 -0700
@@ -0,0 +1,8 @@
+MacFUSE Project Page:
+
+http://code.google.com/p/macfuse/
+
+Making a Universal build of libfuse:
+
+0. Run ./darwin_configure.sh
+1. Run make
diff -Naur old/configure new/configure
--- old/configure	2007-07-02 04:49:44.000000000 -0700
+++ new/configure	2007-09-16 12:14:59.000000000 -0700
@@ -11293,7 +11293,8 @@
 fi
 
 
-libfuse_libs="-pthread"
+#libfuse_libs="-pthread"
+libfuse_libs=
 LIBS=
 { echo "$as_me:$LINENO: checking for library containing dlopen" >&5
 echo $ECHO_N "checking for library containing dlopen... $ECHO_C" >&6; }
diff -Naur old/configure.in new/configure.in
--- old/configure.in	2007-07-02 04:32:15.000000000 -0700
+++ new/configure.in	2007-09-16 12:14:59.000000000 -0700
@@ -16,6 +16,7 @@
 case $target_os in
      *linux*)	arch=linux;;
      *bsd*)	arch=bsd;;
+     *darwin*)	arch=darwin;;
      *)		arch=unknown;;
 esac
 
@@ -97,6 +98,7 @@
 
 AM_CONDITIONAL(LINUX, test "$arch" = linux)
 AM_CONDITIONAL(BSD, test "$arch" = bsd)
+AM_CONDITIONAL(DARWIN, test "$arch" = darwin)
 
 AC_CONFIG_FILES([fuse.pc Makefile lib/Makefile util/Makefile example/Makefile include/Makefile])
 AC_OUTPUT
diff -Naur old/darwin_configure.sh new/darwin_configure.sh
--- old/darwin_configure.sh	1969-12-31 16:00:00.000000000 -0800
+++ new/darwin_configure.sh	2007-09-16 13:12:33.000000000 -0700
@@ -0,0 +1,6 @@
+#! /bin/sh
+
+MACFUSE_SRCROOT=${MACFUSE_SRCROOT:-$1}
+MACFUSE_SRCROOT=${MACFUSE_SRCROOT:?}
+
+CFLAGS="-D__FreeBSD__=10 -D_POSIX_C_SOURCE=200112L -I$MACFUSE_SRCROOT/common -O -g -arch i386 -arch ppc -isysroot /Developer/SDKs/MacOSX10.5.sdk" LDFLAGS="-arch i386 -arch ppc -framework CoreFoundation" ./configure --prefix=/usr/local --disable-dependency-tracking
diff -Naur old/example/fusexmp.c new/example/fusexmp.c
--- old/example/fusexmp.c	2007-05-20 04:05:42.000000000 -0700
+++ new/example/fusexmp.c	2007-09-16 12:14:59.000000000 -0700
@@ -47,8 +47,25 @@
     int res;
 
     res = access(path, mask);
-    if (res == -1)
+    if (res == -1) {
+#if (__FreeBSD__ >= 10)
+        if (errno == ENOENT) {
+            int next_res;
+            struct stat sb;
+            next_res = lstat(path, &sb);
+            if (next_res == 0 && S_ISLNK(sb.st_mode) &&
+                ((sb.st_uid == getuid()) || (geteuid() == 0))) {
+                /*
+                 * The target of the symlink doesn't exist, but the
+                 * symlink itself does. A lame cheap fix here.
+                 */
+                return 0;
+            }
+            return -ENOENT;
+        }
+#endif
         return -errno;
+    }  /* if (res == -1) */
 
     return 0;
 }
@@ -316,7 +333,11 @@
 static int xmp_setxattr(const char *path, const char *name, const char *value,
                         size_t size, int flags)
 {
+#if (__FreeBSD__ >= 10)
+    int res = setxattr(path, name, value, size, 0, flags);
+#else
     int res = lsetxattr(path, name, value, size, flags);
+#endif
     if (res == -1)
         return -errno;
     return 0;
@@ -325,7 +346,11 @@
 static int xmp_getxattr(const char *path, const char *name, char *value,
                     size_t size)
 {
+#if (__FreeBSD__ >= 10)
+    int res = getxattr(path, name, value, size, 0, 0);
+#else
     int res = lgetxattr(path, name, value, size);
+#endif
     if (res == -1)
         return -errno;
     return res;
@@ -333,7 +358,11 @@
 
 static int xmp_listxattr(const char *path, char *list, size_t size)
 {
+#if (__FreeBSD__ >= 10)
+    int res = listxattr(path, list, size, 0);
+#else
     int res = llistxattr(path, list, size);
+#endif
     if (res == -1)
         return -errno;
     return res;
@@ -341,7 +370,11 @@
 
 static int xmp_removexattr(const char *path, const char *name)
 {
+#if (__FreeBSD__ >= 10)
+    int res = removexattr(path, name, 0);
+#else
     int res = lremovexattr(path, name);
+#endif
     if (res == -1)
         return -errno;
     return 0;
diff -Naur old/example/fusexmp_fh.c new/example/fusexmp_fh.c
--- old/example/fusexmp_fh.c	2007-05-20 04:05:43.000000000 -0700
+++ new/example/fusexmp_fh.c	2007-09-16 12:14:59.000000000 -0700
@@ -29,13 +29,27 @@
 #include <sys/xattr.h>
 #endif
 
+#include <sys/param.h>
+
+#if (__FreeBSD__ >= 10)
+
+#define G_PREFIX              "org"
+#define G_KAUTH_FILESEC_XATTR G_PREFIX ".apple.system.Security"
+#define A_PREFIX              "com"
+#define A_KAUTH_FILESEC_XATTR A_PREFIX ".apple.system.Security"
+#define XATTR_APPLE_PREFIX    "com.apple."
+
+#endif
+
+
 static int xmp_getattr(const char *path, struct stat *stbuf)
 {
     int res;
 
     res = lstat(path, stbuf);
-    if (res == -1)
+    if (res == -1) {
         return -errno;
+    }
 
     return 0;
 }
@@ -59,8 +73,25 @@
     int res;
 
     res = access(path, mask);
-    if (res == -1)
+    if (res == -1) {
+#if (__FreeBSD__ >= 10)
+        if (errno == ENOENT) {
+            int next_res;
+            struct stat sb;
+            next_res = lstat(path, &sb);
+            if (next_res == 0 && S_ISLNK(sb.st_mode) &&
+                ((sb.st_uid == getuid()) || (geteuid() == 0))) {
+                /*
+                 * The target of the symlink doesn't exist, but the
+                 * symlink itself does. A lame cheap fix here.
+                 */
+                return 0;
+            }
+            return -ENOENT;
+        }
+#endif
         return -errno;
+    }  /* if (res == -1) */
 
     return 0;
 }
@@ -375,7 +406,22 @@
 static int xmp_setxattr(const char *path, const char *name, const char *value,
                         size_t size, int flags)
 {
+#if (__FreeBSD__ >= 10)
+    int res;
+    if (!strncmp(name, XATTR_APPLE_PREFIX, sizeof(XATTR_APPLE_PREFIX) - 1)) {
+        flags &= ~(XATTR_NOSECURITY);
+    }
+    if (!strcmp(name, A_KAUTH_FILESEC_XATTR)) {
+        char new_name[MAXPATHLEN];
+        memcpy(new_name, A_KAUTH_FILESEC_XATTR, sizeof(A_KAUTH_FILESEC_XATTR));
+        memcpy(new_name, G_PREFIX, sizeof(G_PREFIX) - 1);
+        res = setxattr(path, new_name, value, size, 0, flags);
+    } else {
+        res = setxattr(path, name, value, size, 0, flags);
+    }
+#else
     int res = lsetxattr(path, name, value, size, flags);
+#endif
     if (res == -1)
         return -errno;
     return 0;
@@ -384,7 +430,19 @@
 static int xmp_getxattr(const char *path, const char *name, char *value,
                     size_t size)
 {
+#if (__FreeBSD__ >= 10)
+    int res;
+    if (strcmp(name, A_KAUTH_FILESEC_XATTR) == 0) {
+        char new_name[MAXPATHLEN];
+        memcpy(new_name, A_KAUTH_FILESEC_XATTR, sizeof(A_KAUTH_FILESEC_XATTR));
+        memcpy(new_name, G_PREFIX, sizeof(G_PREFIX) - 1);
+        res = getxattr(path, new_name, value, size, 0, 0);
+    } else {
+        res = getxattr(path, name, value, size, 0, 0);
+    }
+#else
     int res = lgetxattr(path, name, value, size);
+#endif
     if (res == -1)
         return -errno;
     return res;
@@ -392,7 +450,32 @@
 
 static int xmp_listxattr(const char *path, char *list, size_t size)
 {
+#if (__FreeBSD__ >= 10)
+    ssize_t res = listxattr(path, list, size, 0);
+    if (res > 0) {
+        if (list) {
+            size_t len = 0;
+            char *curr = list;
+            do { 
+                size_t thislen = strlen(curr) + 1;
+                if (strcmp(curr, G_KAUTH_FILESEC_XATTR) == 0) {
+                    memmove(curr, curr + thislen, res - len - thislen);
+                    res -= thislen;
+                    break;
+                }
+                curr += thislen;
+                len += thislen;
+            } while (len < res);
+        } else {
+            ssize_t res2 = getxattr(path, G_KAUTH_FILESEC_XATTR, NULL, 0, 0, 0);
+            if (res2 >= 0) {
+                res -= sizeof(G_KAUTH_FILESEC_XATTR);
+            }
+        }
+    }
+#else
     int res = llistxattr(path, list, size);
+#endif
     if (res == -1)
         return -errno;
     return res;
@@ -400,7 +483,19 @@
 
 static int xmp_removexattr(const char *path, const char *name)
 {
+#if (__FreeBSD__ >= 10)
+    int res;
+    if (strcmp(name, A_KAUTH_FILESEC_XATTR) == 0) {
+        char new_name[MAXPATHLEN];
+        memcpy(new_name, A_KAUTH_FILESEC_XATTR, sizeof(A_KAUTH_FILESEC_XATTR));
+        memcpy(new_name, G_PREFIX, sizeof(G_PREFIX) - 1);
+        res = removexattr(path, new_name, 0);
+    } else {
+        res = removexattr(path, name, 0);
+    }
+#else
     int res = lremovexattr(path, name);
+#endif
     if (res == -1)
         return -errno;
     return 0;
@@ -416,7 +511,20 @@
                        sizeof(fi->lock_owner));
 }
 
+void *
+xmp_init(struct fuse_conn_info *conn)
+{
+    return NULL;
+}
+
+void
+xmp_destroy(void *userdata)
+{
+}
+
 static struct fuse_operations xmp_oper = {
+    .init       = xmp_init,
+    .destroy    = xmp_destroy,
     .getattr	= xmp_getattr,
     .fgetattr	= xmp_fgetattr,
     .access	= xmp_access,
diff -Naur old/fuse.pc.in new/fuse.pc.in
--- old/fuse.pc.in	2006-12-02 05:38:07.000000000 -0800
+++ new/fuse.pc.in	2007-09-16 12:14:59.000000000 -0700
@@ -4,7 +4,7 @@
 includedir=@includedir@
 
 Name: fuse
-Description: Filesystem in Userspace
+Description: File System in User Space (MacFUSE)
 Version: @VERSION@
 Libs: -L${libdir} -lfuse @libfuse_libs@
-Cflags: -I${includedir}/fuse -D_FILE_OFFSET_BITS=64
+Cflags: -I${includedir}/fuse -D__FreeBSD__=10 -D_FILE_OFFSET_BITS=64
diff -Naur old/include/fuse.h new/include/fuse.h
--- old/include/fuse.h	2007-07-02 04:32:15.000000000 -0700
+++ new/include/fuse.h	2007-09-16 12:14:59.000000000 -0700
@@ -817,4 +817,22 @@
 }
 #endif
 
+#if (__FreeBSD__ >= 10)
+
+#define LIBFUSE_BUNDLE_IDENTIFIER "com.google.filesystems.libfuse"
+
+#define LIBFUSE_UNOTIFICATIONS_OBJECT                 \
+    LIBFUSE_BUNDLE_IDENTIFIER ".unotifications"
+
+#define LIBFUSE_UNOTIFICATIONS_NOTIFY_OSISTOONEW      \
+    LIBFUSE_BUNDLE_IDENTIFIER ".osistoonew"
+
+#define LIBFUSE_UNOTIFICATIONS_NOTIFY_OSISTOOOLD      \
+    LIBFUSE_BUNDLE_IDENTIFIER ".osistooold"
+
+#define LIBFUSE_UNOTIFICATIONS_NOTIFY_VERSIONMISMATCH \
+    LIBFUSE_BUNDLE_IDENTIFIER ".versionmismatch"
+
+#endif
+
 #endif /* _FUSE_H_ */
diff -Naur old/lib/Makefile.am new/lib/Makefile.am
--- old/lib/Makefile.am	2007-04-25 09:06:46.000000000 -0700
+++ new/lib/Makefile.am	2007-09-16 12:14:59.000000000 -0700
@@ -7,6 +7,8 @@
 
 if BSD
 mount_source = mount_bsd.c
+else if DARWIN
+mount_source = mount_darwin.c
 else
 mount_source = mount.c mount_util.c mount_util.h
 endif
diff -Naur old/lib/Makefile.in new/lib/Makefile.in
--- old/lib/Makefile.in	2007-07-02 04:49:57.000000000 -0700
+++ new/lib/Makefile.in	2007-09-16 12:14:59.000000000 -0700
@@ -61,13 +61,23 @@
 	fuse_mt.c fuse_opt.c fuse_session.c fuse_signals.c helper.c \
 	modules/subdir.c modules/iconv.c mount.c mount_util.c \
 	mount_util.h mount_bsd.c
+ifeq (@host_vendor@, apple)
+am__libfuse_la_SOURCES_DIST += modules/volicon.c mount_darwin.c
+endif
 @ICONV_TRUE@am__objects_1 = iconv.lo
+ifeq (@host_vendor@, apple)
+am__objects_1 = mount_darwin.lo
+else
 @BSD_FALSE@am__objects_2 = mount.lo mount_util.lo
 @BSD_TRUE@am__objects_2 = mount_bsd.lo
+endif
 am_libfuse_la_OBJECTS = fuse.lo fuse_kern_chan.lo fuse_loop.lo \
 	fuse_loop_mt.lo fuse_lowlevel.lo fuse_mt.lo fuse_opt.lo \
 	fuse_session.lo fuse_signals.lo helper.lo subdir.lo \
 	$(am__objects_1) $(am__objects_2)
+ifeq (@host_vendor@, apple)
+am_libfuse_la_OBJECTS += volicon.lo
+endif
 libfuse_la_OBJECTS = $(am_libfuse_la_OBJECTS)
 libulockmgr_la_LIBADD =
 am_libulockmgr_la_OBJECTS = ulockmgr.lo
@@ -209,8 +219,12 @@
  -D_FILE_OFFSET_BITS=64 -D_REENTRANT -DFUSE_USE_VERSION=26
 
 lib_LTLIBRARIES = libfuse.la libulockmgr.la
+ifeq (@host_vendor@, apple)
+mount_source = mount_darwin.c
+else
 @BSD_FALSE@mount_source = mount.c mount_util.c mount_util.h
 @BSD_TRUE@mount_source = mount_bsd.c
+endif
 @ICONV_FALSE@iconv_source = 
 @ICONV_TRUE@iconv_source = modules/iconv.c
 libfuse_la_SOURCES = \
@@ -230,8 +244,13 @@
 	$(iconv_source)		\
 	$(mount_source)
 
+ifeq ($(host_vendor), apple)
+libfuse_la_SOURCES += modules/volicon.c
+libfuse_la_LDFLAGS = @libfuse_libs@
+else
 libfuse_la_LDFLAGS = @libfuse_libs@ -version-number 2:7:0 \
 	-Wl,--version-script,$(srcdir)/fuse_versionscript
+endif
 
 libulockmgr_la_SOURCES = ulockmgr.c
 libulockmgr_la_LDFLAGS = -version-number 1:0:1
@@ -323,6 +342,10 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mount_util.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/subdir.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ulockmgr.Plo@am__quote@
+ifeq (@host_vendor@, apple)
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/volicon.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mount_darwin.Plo@am__quote@
+endif
 
 .c.o:
 @am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ $<; \
@@ -359,6 +382,15 @@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o iconv.lo `test -f 'modules/iconv.c' || echo '$(srcdir)/'`modules/iconv.c
 
+ifeq (@host_vendor@, apple)
+volicon.lo: modules/volicon.c
+@am__fastdepCC_TRUE@	if $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT volicon.lo -MD -MP -MF "$(DEPDIR)/volicon.Tpo" -c -o volicon.lo `test -f 'modules/volicon.c' || echo '$(srcdir)/'`modules/volicon.c; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/volicon.Tpo" "$(DEPDIR)/volicon.Plo"; else rm -f "$(DEPDIR)/volicon.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='modules/volicon.c' object='volicon.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o volicon.lo `test -f 'modules/volicon.c' || echo '$(srcdir)/'`modules/volicon.c
+endif
+
 mostlyclean-libtool:
 	-rm -f *.lo
 
diff -Naur old/lib/darwin_compat.h new/lib/darwin_compat.h
--- old/lib/darwin_compat.h	1969-12-31 16:00:00.000000000 -0800
+++ new/lib/darwin_compat.h	2007-09-16 12:14:59.000000000 -0700
@@ -0,0 +1,163 @@
+/*
+ * Copyright (C) 2006,2007 Google. All Rights Reserved.
+ * Amit Singh <singh@>
+ */
+
+#ifndef _DARWIN_COMPAT_H_
+#define _DARWIN_COMPAT_H_
+
+#include <AvailabilityMacros.h>
+
+#ifdef MAC_OS_X_VERSION_10_5
+
+/* 10.5+ */
+
+/* Half-baked makeshift implementation (cancelable). */
+
+#include <errno.h>
+#include <sys/types.h>
+#include <pthread.h>
+    
+typedef struct {
+    int32_t         value;
+    int32_t         wakeups;
+    pthread_mutex_t mutex;
+    pthread_cond_t  cond;
+} fuse_sem_t;
+
+typedef fuse_sem_t sem_t;
+        
+#define SEM_VALUE_DEAD ((int32_t)0xdeadbeef)
+#define SEM_VALUE_MAX  ((int32_t)32767)
+
+/* http://www.opengroup.org/onlinepubs/007908799/xsh/sem_init.html */
+static __inline__
+int
+fuse_sem_init(fuse_sem_t *sem, int pshared, int value)
+{
+
+    if (value > SEM_VALUE_MAX) {
+        errno = EINVAL;
+        return -1;
+    }
+
+    if (pshared) {
+        errno = ENOSYS;
+        return -1;
+    }
+
+    if (!sem) {
+        errno = EINVAL;
+        return -1;
+    }
+
+    sem->value = value;
+    sem->wakeups = 0;
+    pthread_cond_init(&sem->cond, NULL);
+    pthread_mutex_init(&sem->mutex, NULL);
+
+    return 0;
+}
+
+/* http://www.opengroup.org/onlinepubs/007908799/xsh/sem_destroy.html */
+static __inline__
+int
+fuse_sem_destroy(fuse_sem_t *sem)
+{
+    int ret;
+
+    if (!sem) {
+        errno = EINVAL;
+        return -1;
+    }
+
+    ret = pthread_mutex_lock(&sem->mutex);
+    if (ret) {
+        errno = ret;
+        return -1;
+    }
+
+    if (sem->value < 0) {
+        pthread_mutex_unlock(&sem->mutex);
+        errno = EBUSY;
+        return -1;
+    }
+
+    pthread_cond_destroy(&sem->cond);
+
+    sem->value = SEM_VALUE_DEAD;
+
+    pthread_mutex_unlock(&sem->mutex);
+    pthread_mutex_destroy(&sem->mutex);
+
+    return 0;
+}
+
+/* http://www.opengroup.org/onlinepubs/007908799/xsh/sem_wait.html */
+static __inline__
+int
+fuse_sem_wait(fuse_sem_t *sem)
+{
+    if (!sem || (sem->value == SEM_VALUE_DEAD)) {
+        errno = EINVAL;
+        return -1;
+    }
+
+    pthread_mutex_lock(&sem->mutex);
+    sem->value--;
+    if (sem->value < 0) {
+        do {
+            /*
+             * XXX: This is not really supposed to fail except for some EINVALs
+             *      that shouldn't apply here.
+             */
+            (void)pthread_cond_wait(&sem->cond, &sem->mutex);
+        } while (sem->wakeups < 1);
+        sem->wakeups--;
+    }
+    pthread_mutex_unlock(&sem->mutex);
+
+    return 0;
+}
+
+/* http://www.opengroup.org/onlinepubs/007908799/xsh/sem_post.html */
+static __inline__
+int
+fuse_sem_post(fuse_sem_t *sem)
+{
+    if (!sem || (sem->value == SEM_VALUE_DEAD)) {
+        errno = EINVAL;
+        return -1;
+    }
+
+    pthread_mutex_lock(&sem->mutex);
+    sem->value++;
+    if (sem->value <= 0) {
+        sem->wakeups++;
+        (void)pthread_cond_signal(&sem->cond);
+    }
+    pthread_mutex_unlock(&sem->mutex);
+
+    return 0;
+}
+
+#define sem_init(s, a, b) fuse_sem_init(s, a, b)
+#define sem_destroy(s)    fuse_sem_destroy(s)
+#define sem_post(s)       fuse_sem_post(s)
+#define sem_wait(s)       fuse_sem_wait(s)
+
+#else
+
+/* 10.4- */
+
+#include <mach/mach.h>
+
+#define sem_init(s, a, b) semaphore_create(mach_task_self(), (s), \
+                                           SYNC_POLICY_FIFO, 0)
+#define sem_destroy(s)    semaphore_destroy(mach_task_self(), (semaphore_t)*(s))
+#define sem_post(s)       semaphore_signal((semaphore_t)*(s))
+#define sem_wait(s)       semaphore_wait((semaphore_t)*(s))
+
+#endif /* MAC_OS_X_VERSION_10.5 */
+
+#endif /* _DARWIN_COMPAT_H_ */
diff -Naur old/lib/fuse.c new/lib/fuse.c
--- old/lib/fuse.c	2007-07-02 04:33:08.000000000 -0700
+++ new/lib/fuse.c	2007-09-16 12:14:59.000000000 -0700
@@ -1172,6 +1172,16 @@
 
 static void curr_time(struct timespec *now)
 {
+#if (__FreeBSD__ >= 10)
+#define MACFUSE_TIMEVAL_TO_TIMESPEC(tv, ts) {                           \
+        (ts)->tv_sec = (tv)->tv_sec;                                    \
+        (ts)->tv_nsec = (tv)->tv_usec * 1000;                           \
+    }
+    struct timeval tp;
+    gettimeofday(&tp, NULL);
+    /* XXX: TBD: We are losing resolution here. */
+    MACFUSE_TIMEVAL_TO_TIMESPEC(&tp, now);
+#else
     static clockid_t clockid = CLOCK_MONOTONIC;
     int res = clock_gettime(clockid, now);
     if (res == -1 && errno == EINVAL) {
@@ -1182,6 +1192,7 @@
         perror("fuse: clock_gettime");
         abort();
     }
+#endif
 }
 
 static void update_stat(struct node *node, const struct stat *stbuf)
@@ -1425,6 +1436,7 @@
 
 int fuse_fs_chmod(struct fuse_fs *fs, const char *path, mode_t mode)
 {
+    fuse_get_context()->private_data = fs->user_data;
     if (fs->op.chmod)
         return fs->op.chmod(path, mode);
     else
@@ -3289,12 +3301,14 @@
                                   sizeof(struct fuse_operations_compat1), 11);
 }
 
+#if !(__FreeBSD__ >= 10)
 __asm__(".symver fuse_exited,__fuse_exited@");
 __asm__(".symver fuse_process_cmd,__fuse_process_cmd@");
 __asm__(".symver fuse_read_cmd,__fuse_read_cmd@");
 __asm__(".symver fuse_set_getcontext_func,__fuse_set_getcontext_func@");
 __asm__(".symver fuse_new_compat2,fuse_new@");
 __asm__(".symver fuse_new_compat22,fuse_new@FUSE_2.2");
+#endif
 
 #endif /* __FreeBSD__ */
 
@@ -3306,4 +3320,6 @@
                                     op_size, 25);
 }
 
+#if !(__FreeBSD__ >= 10)
 __asm__(".symver fuse_new_compat25,fuse_new@FUSE_2.5");
+#endif
diff -Naur old/lib/fuse_kern_chan.c new/lib/fuse_kern_chan.c
--- old/lib/fuse_kern_chan.c	2007-05-20 04:05:46.000000000 -0700
+++ new/lib/fuse_kern_chan.c	2007-09-16 12:14:59.000000000 -0700
@@ -75,9 +75,19 @@
     return 0;
 }
 
+#if (__FreeBSD__ >= 10)
+#include "macfuse.h"
+#endif
+
 static void fuse_kern_chan_destroy(struct fuse_chan *ch)
 {
+#if (__FreeBSD__ >= 10)
+    int fd = fuse_chan_fd(ch);
+    (void)ioctl(fd, FUSEDEVIOCSETDAEMONDEAD, &fd);
+    close(fd);
+#else
     close(fuse_chan_fd(ch));
+#endif
 }
 
 #define MIN_BUFSIZE 0x21000
diff -Naur old/lib/fuse_loop_mt.c new/lib/fuse_loop_mt.c
--- old/lib/fuse_loop_mt.c	2007-07-02 04:32:17.000000000 -0700
+++ new/lib/fuse_loop_mt.c	2007-09-16 12:14:59.000000000 -0700
@@ -15,7 +15,11 @@
 #include <string.h>
 #include <unistd.h>
 #include <signal.h>
+#if (__FreeBSD__ >= 10)
+#include "darwin_compat.h"
+#else
 #include <semaphore.h>
+#endif
 #include <errno.h>
 #include <sys/time.h>
 
diff -Naur old/lib/fuse_lowlevel.c new/lib/fuse_lowlevel.c
--- old/lib/fuse_lowlevel.c	2007-07-02 04:32:17.000000000 -0700
+++ new/lib/fuse_lowlevel.c	2007-09-16 12:14:59.000000000 -0700
@@ -450,6 +450,8 @@
 
     if (req->f->op.forget)
         req->f->op.forget(req, nodeid, arg->nlookup);
+    else
+        fuse_reply_none(req);
 }
 
 static void do_getattr(fuse_req_t req, fuse_ino_t nodeid, const void *inarg)
@@ -1407,9 +1409,11 @@
     return 0;
 }
 
+#if !(__FreeBSD__ >= 10)
 __asm__(".symver fuse_reply_statfs_compat,fuse_reply_statfs@FUSE_2.4");
 __asm__(".symver fuse_reply_open_compat,fuse_reply_open@FUSE_2.4");
 __asm__(".symver fuse_lowlevel_new_compat,fuse_lowlevel_new@FUSE_2.4");
+#endif
 
 #else /* __FreeBSD__ */
 
@@ -1433,4 +1437,6 @@
                                     op_size, userdata);
 }
 
+#if !(__FreeBSD__ >= 10)
 __asm__(".symver fuse_lowlevel_new_compat25,fuse_lowlevel_new@FUSE_2.5");
+#endif
diff -Naur old/lib/fuse_mt.c new/lib/fuse_mt.c
--- old/lib/fuse_mt.c	2007-04-25 09:14:26.000000000 -0700
+++ new/lib/fuse_mt.c	2007-09-16 12:14:59.000000000 -0700
@@ -112,4 +112,6 @@
     return fuse_session_loop_mt(fuse_get_session(f));
 }
 
+#if !(__FreeBSD__ >= 10)
 __asm__(".symver fuse_loop_mt_proc,__fuse_loop_mt@");
+#endif
diff -Naur old/lib/fuse_opt.c new/lib/fuse_opt.c
--- old/lib/fuse_opt.c	2007-04-25 09:14:26.000000000 -0700
+++ new/lib/fuse_opt.c	2007-09-16 12:14:59.000000000 -0700
@@ -27,11 +27,14 @@
 
 void fuse_opt_free_args(struct fuse_args *args)
 {
-    if (args && args->argv && args->allocated) {
-        int i;
-        for (i = 0; i < args->argc; i++)
-            free(args->argv[i]);
-        free(args->argv);
+    if (args) {
+        if (args->argv && args->allocated) {
+            int i;
+            for (i = 0; i < args->argc; i++)
+                free(args->argv[i]);
+            free(args->argv);
+        }
+        args->argc = 0;
         args->argv = NULL;
         args->allocated = 0;
     }
diff -Naur old/lib/fuse_session.c new/lib/fuse_session.c
--- old/lib/fuse_session.c	2007-04-25 09:14:26.000000000 -0700
+++ new/lib/fuse_session.c	2007-09-16 12:14:59.000000000 -0700
@@ -15,6 +15,9 @@
 #include <string.h>
 #include <assert.h>
 #include <errno.h>
+#if (__FreeBSD__ >= 10)
+#include <sys/param.h>
+#endif
 
 struct fuse_session {
     struct fuse_session_ops op;
@@ -24,6 +27,10 @@
     volatile int exited;
 
     struct fuse_chan *ch;
+
+#if (__FreeBSD__ >= 10)
+    char mntonname[MAXPATHLEN];
+#endif
 };
 
 struct fuse_chan {
@@ -40,6 +47,30 @@
     int compat;
 };
 
+#if (__FreeBSD__ >= 10)
+char *fuse_session_get_mntonname(struct fuse_session *se)
+{
+    if (se) {
+        return se->mntonname;
+    }
+
+    return NULL;
+}
+
+void fuse_session_set_mntonname(struct fuse_session *se, char *mntonname)
+{
+    if (!se || !mntonname) {
+        return;
+    }
+
+    if (!realpath(mntonname, se->mntonname)) {
+        memset(se->mntonname, 0, MAXPATHLEN);
+    }
+
+    return;
+}
+#endif
+
 struct fuse_session *fuse_session_new(struct fuse_session_ops *op, void *data)
 {
     struct fuse_session *se = (struct fuse_session *) malloc(sizeof(*se));
diff -Naur old/lib/fuse_signals.c new/lib/fuse_signals.c
--- old/lib/fuse_signals.c	2007-04-25 09:14:26.000000000 -0700
+++ new/lib/fuse_signals.c	2007-09-16 12:14:59.000000000 -0700
@@ -13,12 +13,34 @@
 #include <signal.h>
 
 static struct fuse_session *fuse_instance;
+#if (__FreeBSD__ >= 10)
+extern char *fuse_session_get_mntonname(struct fuse_session *se);
+
+#include <unistd.h>
+#endif
 
 static void exit_handler(int sig)
 {
     (void) sig;
+#if (__FreeBSD__ >= 10)
+    if (fuse_instance && !fuse_session_exited(fuse_instance)) {
+        int fd;
+        pid_t pid;
+
+        fd = fuse_chan_fd(fuse_session_next_chan(fuse_instance, NULL));
+        pid = fork();
+        if (pid == 0) { /* child */
+             char *mntonname = fuse_session_get_mntonname(fuse_instance);
+             fcntl(fd, F_SETFD, 1); /* close-on-exec */
+             execl("/sbin/umount", "/sbin/umount", mntonname, NULL);
+        } else {
+            /* We do nothing in the parent. */
+        }
+    }
+#else
     if (fuse_instance)
         fuse_session_exit(fuse_instance);
+#endif
 }
 
 static int set_one_signal_handler(int sig, void (*handler)(int))
diff -Naur old/lib/helper.c new/lib/helper.c
--- old/lib/helper.c	2007-07-02 04:32:17.000000000 -0700
+++ new/lib/helper.c	2007-09-16 12:14:59.000000000 -0700
@@ -108,6 +108,19 @@
                 fprintf(stderr, "fuse: bad mount point `%s': %s\n", arg, strerror(errno));
                 return -1;
             }
+#if (__FreeBSD__ >= 10)
+            else {
+                struct stat sb;
+                if (stat(mountpoint, &sb) != 0) {
+                    fprintf(stderr, "fuse: failed to stat mount point `%s': %s\n", mountpoint, strerror(errno));
+                    return -1;
+                }
+                if ((sb.st_mode & S_IFMT) != S_IFDIR) {
+                    fprintf(stderr, "fuse: mount point is not a directory `%s'\n", mountpoint);
+                    return -1;
+                }
+            }
+#endif
             return fuse_opt_add_opt(&hopts->mountpoint, mountpoint);
         } else {
             fprintf(stderr, "fuse: invalid argument `%s'\n", arg);
@@ -190,7 +203,19 @@
                                            struct fuse_args *args)
 {
     struct fuse_chan *ch;
-    int fd = fuse_mount_compat25(mountpoint, args);
+    int fd;
+
+    /*
+     * Make sure file descriptors 0, 1 and 2 are open, otherwise chaos
+     * would ensue.
+     */
+    do {
+        fd = open("/dev/null", O_RDWR);
+        if (fd > 2)
+            close(fd);
+    } while (fd >= 0 && fd <= 2);
+
+    fd = fuse_mount_compat25(mountpoint, args);
     if (fd == -1)
         return NULL;
 
@@ -259,6 +284,10 @@
     if (fd)
         *fd = fuse_chan_fd(ch);
 
+#if (__FreeBSD__ >= 10)
+    fuse_session_set_mntonname(fuse_get_session(fuse), *mountpoint);
+#endif
+
     return fuse;
 
  err_unmount:
@@ -390,11 +419,13 @@
     return fuse_mount_compat22(mountpoint, NULL);
 }
 
+#if !(__FreeBSD__ >= 10)
 __asm__(".symver fuse_setup_compat2,__fuse_setup@");
 __asm__(".symver fuse_setup_compat22,fuse_setup@FUSE_2.2");
 __asm__(".symver fuse_teardown,__fuse_teardown@");
 __asm__(".symver fuse_main_compat2,fuse_main@");
 __asm__(".symver fuse_main_real_compat22,fuse_main_real@FUSE_2.2");
+#endif
 
 #endif /* __FreeBSD__ */
 
@@ -427,7 +458,9 @@
     return fuse_kern_mount(mountpoint, args);
 }
 
+#if !(__FreeBSD__ >= 10)
 __asm__(".symver fuse_setup_compat25,fuse_setup@FUSE_2.5");
 __asm__(".symver fuse_teardown_compat22,fuse_teardown@FUSE_2.2");
 __asm__(".symver fuse_main_real_compat25,fuse_main_real@FUSE_2.5");
 __asm__(".symver fuse_mount_compat25,fuse_mount@FUSE_2.5");
+#endif
diff -Naur old/lib/macfuse.h new/lib/macfuse.h
--- old/lib/macfuse.h	1969-12-31 16:00:00.000000000 -0800
+++ new/lib/macfuse.h	2007-09-16 13:16:32.000000000 -0700
@@ -0,0 +1,15 @@
+/*
+ * Copyright (C) 2006 Google. All Rights Reserved.
+ * Amit Singh <singh@>
+ */
+
+#ifndef _MACFUSE_H_
+#define _MACFUSE_H_
+
+/* From the MacFUSE kernel/common source. */
+
+#include <fuse_param.h>
+#include <fuse_ioctl.h>
+#include <fuse_version.h>
+
+#endif /* _MACFUSE_H_ */
diff -Naur old/lib/modules/volicon.c new/lib/modules/volicon.c
--- old/lib/modules/volicon.c	1969-12-31 16:00:00.000000000 -0800
+++ new/lib/modules/volicon.c	2007-09-16 12:14:59.000000000 -0700
@@ -0,0 +1,727 @@
+/*
+ *  Custom volume icon support for MacFUSE.
+ *
+ *  - xattr'ification and overhaul by Amit Singh <singh@>
+ *  - Made into a libfuse stack module by Andrew de los Reyes <adlr@google>
+ *  - Original "volicon" code by Amit Singh <singh@>
+ *
+ *  This program can be distributed under the terms of the GNU LGPL.
+ *  See the file COPYING.LIB for details.
+ */
+
+#define FUSE_USE_VERSION 26
+
+#undef _POSIX_C_SOURCE
+#include <sys/types.h>
+#define _POSIX_C_SOURCE 200112L
+#include <sys/attr.h>
+#include <sys/xattr.h>
+#include <sys/vnode.h>
+#include <fuse.h>
+#include <libgen.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <stddef.h>
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+#include <arpa/inet.h>
+
+#define VOLICON_ROOT_MAGIC_PATH    "/"
+#define VOLICON_ICON_MAGIC_PATH    "/.VolumeIcon.icns"
+#define VOLICON_ICON_MAXSIZE       (1024 * 1024)
+
+struct FndrGenericInfo {
+    u_int32_t   ignored0;
+    u_int32_t   ignored1;
+    u_int16_t   flags;
+    struct {
+        int16_t ignored2;
+        int16_t ignored3;
+    } fdLocation;
+    int16_t     ignored4;
+} __attribute__((aligned(2), packed));
+typedef struct FndrGenericInfo FndrGenericInfo;
+
+#define kHasCustomIcon 0x0400
+
+static const char finder_info[32] = {
+    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
+    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
+    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
+    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
+};
+#define XATTR_FINDERINFO_SIZE 32
+
+#define ERROR_IF_MAGIC_FILE(path, e)     \
+    if (volicon_is_a_magic_file(path)) { \
+        return -e;                       \
+    }
+
+struct volicon {
+    char *volicon;
+    char *volicon_data;
+    off_t volicon_size;
+    uid_t volicon_uid;
+
+    struct fuse_fs *next;
+};
+
+static struct volicon *
+volicon_get(void)
+{
+    return fuse_get_context()->private_data;
+}
+
+static __inline__ int
+volicon_is_icon_magic_file(const char *path)
+{
+    return (!strcmp(path, VOLICON_ICON_MAGIC_PATH));
+}
+
+static __inline__ int
+volicon_is_a_magic_file(const char *path)
+{
+    return (volicon_is_icon_magic_file(path));
+}
+
+/*
+ * FUSE API Operations
+ * Listed in the same order as in struct fuse_operations in <fuse.h>
+ */
+
+static int
+volicon_getattr(const char *path, struct stat *buf)
+{
+    int res = 0;
+
+    if (volicon_is_icon_magic_file(path)) {
+
+        memset((void *)buf, 0, sizeof(struct stat));
+
+        buf->st_mode  = S_IFREG | 0444;
+        buf->st_nlink = 1;
+        buf->st_uid   = volicon_get()->volicon_uid;
+        buf->st_gid = 0;
+        buf->st_size  = volicon_get()->volicon_size;
+        buf->st_atime = buf->st_ctime = buf->st_mtime = time(NULL);
+
+    } else {
+        res = fuse_fs_getattr(volicon_get()->next, path, buf);
+    }
+
+    return res;
+}
+
+static int
+volicon_readlink(const char *path, char *buf, size_t size)
+{
+    ERROR_IF_MAGIC_FILE(path, EINVAL);
+
+    return fuse_fs_readlink(volicon_get()->next, path, buf, size);
+}
+
+static int
+volicon_getdir(const char *path, struct fuse_dirhandle *dh,
+               fuse_dirfil_t filler_old)
+{
+    ERROR_IF_MAGIC_FILE(path, ENOTDIR);
+
+    return fuse_fs_getdir(volicon_get()->next, path, dh, filler_old);
+}
+
+static int
+volicon_mknod(const char *path, mode_t mode, dev_t rdev)
+{
+    ERROR_IF_MAGIC_FILE(path, EEXIST);
+
+    return fuse_fs_mknod(volicon_get()->next, path, mode, rdev);
+}
+
+static int
+volicon_mkdir(const char *path, mode_t mode)
+{
+    ERROR_IF_MAGIC_FILE(path, EEXIST);
+
+    return fuse_fs_mkdir(volicon_get()->next, path, mode);
+}
+
+static int
+volicon_unlink(const char *path)
+{
+    ERROR_IF_MAGIC_FILE(path, EACCES);
+
+    return fuse_fs_unlink(volicon_get()->next, path);
+}
+
+static int
+volicon_rmdir(const char *path)
+{
+    ERROR_IF_MAGIC_FILE(path, ENOTDIR);
+
+    return fuse_fs_rmdir(volicon_get()->next, path);
+}
+
+static int
+volicon_symlink(const char *from, const char *path)
+{
+    ERROR_IF_MAGIC_FILE(path, EEXIST);
+
+    return fuse_fs_symlink(volicon_get()->next, from, path);
+}
+
+static int volicon_rename(const char *from, const char *to)
+{
+    ERROR_IF_MAGIC_FILE(from, EACCES);
+    ERROR_IF_MAGIC_FILE(to, EACCES);
+
+    return fuse_fs_rename(volicon_get()->next, from, to);
+}
+
+static int
+volicon_link(const char *from, const char *to)
+{
+    ERROR_IF_MAGIC_FILE(from, EACCES);
+    ERROR_IF_MAGIC_FILE(to, EACCES);
+
+    return fuse_fs_link(volicon_get()->next, from, to);
+}
+
+static int
+volicon_chmod(const char *path, mode_t mode)
+{
+    ERROR_IF_MAGIC_FILE(path, EACCES);
+
+    return fuse_fs_chmod(volicon_get()->next, path, mode);
+}
+
+static int
+volicon_chown(const char *path, uid_t uid, gid_t gid)
+{
+    ERROR_IF_MAGIC_FILE(path, EACCES);
+
+    return fuse_fs_chown(volicon_get()->next, path, uid, gid);
+}
+
+static int
+volicon_truncate(const char *path, off_t size)
+{
+    ERROR_IF_MAGIC_FILE(path, EACCES);
+
+    return fuse_fs_truncate(volicon_get()->next, path, size);
+}
+
+static int
+volicon_utime(const char *path, struct utimbuf *buf)
+{
+    ERROR_IF_MAGIC_FILE(path, EACCES);
+
+    return fuse_fs_utime(volicon_get()->next, path, buf);
+}
+
+static int
+volicon_open(const char *path, struct fuse_file_info *fi)
+{
+    if (volicon_is_a_magic_file(path)) {
+        if (fi && ((fi->flags & O_ACCMODE) != O_RDONLY)) {
+            return -EACCES;
+        }
+
+        return 0;
+    }
+
+    return fuse_fs_open(volicon_get()->next, path, fi);
+}
+
+static int
+volicon_read(const char *path, char *buf, size_t size, off_t off,
+             struct fuse_file_info *fi)
+{
+    int res = 0;
+
+    if (volicon_is_icon_magic_file(path)) {
+        size_t a_size = size;
+        if (off < volicon_get()->volicon_size) {
+            if ((off + size) > volicon_get()->volicon_size) {
+                a_size = volicon_get()->volicon_size - off;
+            }
+            memcpy(buf, (char *)(volicon_get()->volicon_data) + off, a_size);
+            res = a_size;
+        }
+    } else {
+        res = fuse_fs_read(volicon_get()->next, path, buf, size, off, fi);
+    }
+
+    return res;
+}
+
+static int
+volicon_write(const char *path, const char *buf, size_t size, off_t off,
+              struct fuse_file_info *fi)
+{
+    ERROR_IF_MAGIC_FILE(path, EACCES);
+
+    return fuse_fs_write(volicon_get()->next, path, buf, size, off, fi);
+}
+
+static int
+volicon_statfs(const char *path, struct statvfs *stbuf)
+{
+    if (volicon_is_a_magic_file(path)) {
+        return fuse_fs_statfs(volicon_get()->next, "/", stbuf);
+    }
+
+    return fuse_fs_statfs(volicon_get()->next, path, stbuf);
+}
+
+static int
+volicon_flush(const char *path, struct fuse_file_info *fi)
+{
+    ERROR_IF_MAGIC_FILE(path, 0);
+
+    return fuse_fs_flush(volicon_get()->next, path, fi);
+}
+
+static int
+volicon_release(const char *path, struct fuse_file_info *fi)
+{
+    ERROR_IF_MAGIC_FILE(path, 0);
+
+    return fuse_fs_release(volicon_get()->next, path, fi);
+}
+
+static int
+volicon_fsync(const char *path, int isdatasync,
+                        struct fuse_file_info *fi)
+{
+    ERROR_IF_MAGIC_FILE(path, 0);
+
+    return fuse_fs_fsync(volicon_get()->next, path, isdatasync, fi);
+}
+
+static int
+volicon_setxattr(const char *path, const char *name, const char *value,
+                 size_t size, int flags)
+{
+    ERROR_IF_MAGIC_FILE(path, EPERM);
+
+    if ((strcmp(path, VOLICON_ROOT_MAGIC_PATH) == 0) &&
+        (strcmp(name, XATTR_FINDERINFO_NAME) == 0)) {
+        if ((size >= 8) && (size <= XATTR_FINDERINFO_SIZE)) {
+            char finder_info[XATTR_FINDERINFO_SIZE];
+            memcpy(finder_info, value, size);
+            ((struct FndrGenericInfo *)&finder_info)->flags |= ntohs(0x0400);
+            //finder_info[8] |= 0x100;
+            return fuse_fs_setxattr(volicon_get()->next, path, name,
+                                    finder_info, size, flags);
+        }
+    }
+
+    return fuse_fs_setxattr(volicon_get()->next, path, name, value, size,
+                            flags);
+}
+
+static int
+volicon_getxattr(const char *path, const char *name, char *value, size_t size)
+{
+    ERROR_IF_MAGIC_FILE(path, EPERM);
+
+    if ((strcmp(path, VOLICON_ROOT_MAGIC_PATH) == 0) &&
+        (strcmp(name, XATTR_FINDERINFO_NAME) == 0)) {
+
+        ssize_t res;
+
+        if (!size || !value) {
+            return XATTR_FINDERINFO_SIZE;
+        }
+
+        if (size < XATTR_FINDERINFO_SIZE) {
+            return -ERANGE;
+        }
+
+        res = fuse_fs_getxattr(volicon_get()->next, path, name, value, size);
+
+        if (res != XATTR_FINDERINFO_SIZE) {
+            memcpy(value, finder_info, XATTR_FINDERINFO_SIZE);
+        }
+
+        ((struct FndrGenericInfo *)value)->flags |= ntohs(0x0400);
+
+        return XATTR_FINDERINFO_SIZE;
+    }
+
+    return fuse_fs_getxattr(volicon_get()->next, path, name, value, size);
+}
+
+static int
+volicon_listxattr(const char *path, char *list, size_t size)
+{
+    ERROR_IF_MAGIC_FILE(path, EPERM);
+
+    if ((strcmp(path, VOLICON_ROOT_MAGIC_PATH) == 0)) {
+        int done = 0;
+        ssize_t sz = sizeof(XATTR_FINDERINFO_NAME);
+        ssize_t res = fuse_fs_listxattr(volicon_get()->next, path, list, size);
+
+        if (!list) { /* size being queried */
+            if (res > 0) {
+                sz += res;
+            }
+            return sz;
+        }
+
+        /* list is good */
+
+        if (res == -ERANGE) {
+            return -ERANGE;
+        }
+
+        if (res > 0) {
+            size_t len = 0;
+            char *curr = list;
+            do {
+                size_t thislen = strlen(curr) + 1;
+                if (strcmp(curr, XATTR_FINDERINFO_NAME) == 0) {
+                    done = 1;
+                    break;
+                }
+                curr += thislen;
+                len += thislen;
+            } while (len < res);
+        }
+
+        if (done) {
+            return res;
+        }
+
+        if (size < (res + sizeof(XATTR_FINDERINFO_NAME))) {
+            return -ERANGE;
+        }
+
+        memcpy((char *)list + res, XATTR_FINDERINFO_NAME,
+               sizeof(XATTR_FINDERINFO_NAME));
+
+        return (res + sizeof(XATTR_FINDERINFO_NAME));
+    }
+
+    return fuse_fs_listxattr(volicon_get()->next, path, list, size);
+}
+
+static int
+volicon_removexattr(const char *path, const char *name)
+{
+    ERROR_IF_MAGIC_FILE(path, EPERM);
+
+    if ((strcmp(path, VOLICON_ROOT_MAGIC_PATH) == 0) &&
+        (strcmp(name, XATTR_FINDERINFO_NAME) == 0)) {
+        return -EACCES;
+    }
+
+    return fuse_fs_removexattr(volicon_get()->next, path, name);
+}
+
+static int
+volicon_opendir(const char *path, struct fuse_file_info *fi)
+{
+    ERROR_IF_MAGIC_FILE(path, ENOTDIR);
+
+    return fuse_fs_opendir(volicon_get()->next, path, fi);
+}
+
+static int
+volicon_readdir(const char *path, void *buf, fuse_fill_dir_t filler,
+                off_t offset, struct fuse_file_info *fi)
+{
+    ERROR_IF_MAGIC_FILE(path, ENOTDIR);
+
+    return fuse_fs_readdir(volicon_get()->next, path, buf, filler, offset, fi);
+}
+
+static int
+volicon_releasedir(const char *path, struct fuse_file_info *fi)
+{
+    ERROR_IF_MAGIC_FILE(path, ENOTDIR);
+
+    return fuse_fs_releasedir(volicon_get()->next, path, fi);
+}
+
+static int
+volicon_fsyncdir(const char *path, int isdatasync, struct fuse_file_info *fi)
+{
+    ERROR_IF_MAGIC_FILE(path, ENOTDIR);
+
+    return fuse_fs_fsyncdir(volicon_get()->next, path, isdatasync, fi);
+}
+
+static void *
+volicon_init(struct fuse_conn_info *conn)
+{
+    struct volicon *d = volicon_get();
+
+    fuse_fs_init(d->next, conn);
+
+    return d;
+}
+
+static void
+volicon_destroy(void *data)
+{
+    struct volicon *d = data;
+
+    fuse_fs_destroy(d->next);
+
+    free(d->volicon);
+    free(d->volicon_data);
+    free(d);
+
+    return;
+}
+
+static int
+volicon_access(const char *path, int mask)
+{
+    if (volicon_is_a_magic_file(path)) {
+        if ((mask & W_OK) || (mask & X_OK)) {
+            return -EACCES;
+        }
+
+        return 0;
+    }
+
+    return fuse_fs_access(volicon_get()->next, path, mask);
+}
+
+static int
+volicon_create(const char *path, mode_t mode, struct fuse_file_info *fi)
+{
+    ERROR_IF_MAGIC_FILE(path, EEXIST);
+
+    return fuse_fs_create(volicon_get()->next, path, mode, fi);
+}
+
+static int
+volicon_ftruncate(const char *path, off_t size, struct fuse_file_info *fi)
+{
+    ERROR_IF_MAGIC_FILE(path, EACCES);
+
+    return fuse_fs_ftruncate(volicon_get()->next, path, size, fi);
+}
+
+static int
+volicon_fgetattr(const char *path, struct stat *buf, struct fuse_file_info *fi)
+{
+    int res = 0;
+
+    if (volicon_is_icon_magic_file(path)) {
+
+        memset((void *)buf, 0, sizeof(struct stat));
+
+        buf->st_mode  = S_IFREG | 0444;
+        buf->st_nlink = 1;
+        buf->st_uid   = volicon_get()->volicon_uid;
+        buf->st_gid = 0;
+        buf->st_size  = volicon_get()->volicon_size;
+        buf->st_atime = buf->st_ctime = buf->st_mtime = time(NULL);
+
+    } else {
+        res = fuse_fs_fgetattr(volicon_get()->next, path, buf, fi);
+    }
+
+    return res;
+}
+
+static int
+volicon_lock(const char *path, struct fuse_file_info *fi, int cmd,
+             struct flock *lock)
+{
+    ERROR_IF_MAGIC_FILE(path, ENOTSUP);
+
+    return fuse_fs_lock(volicon_get()->next, path, fi, cmd, lock);
+}
+
+static int
+volicon_utimens(const char *path, const struct timespec ts[2])
+{
+    ERROR_IF_MAGIC_FILE(path, EACCES);
+
+    return fuse_fs_utimens(volicon_get()->next, path, ts);
+}
+
+static int
+volicon_bmap(const char *path, size_t blocksize, uint64_t *idx)
+{
+    ERROR_IF_MAGIC_FILE(path, ENOTSUP);
+
+    return fuse_fs_bmap(volicon_get()->next, path, blocksize, idx);
+}
+
+/*
+ * Listed in the same order as in struct fuse_operations in <fuse.h>
+ */
+static struct fuse_operations volicon_oper = {
+    .getattr     = volicon_getattr,
+    .readlink    = volicon_readlink,
+    .getdir      = volicon_getdir,
+    .mknod       = volicon_mknod,
+    .mkdir       = volicon_mkdir,
+    .unlink      = volicon_unlink,
+    .rmdir       = volicon_rmdir,
+    .symlink     = volicon_symlink,
+    .rename      = volicon_rename,
+    .link        = volicon_link,
+    .chmod       = volicon_chmod,
+    .chown       = volicon_chown,
+    .truncate    = volicon_truncate,
+    .utime       = volicon_utime,
+    .open        = volicon_open,
+    .read        = volicon_read,
+    .write       = volicon_write,
+    .statfs      = volicon_statfs,
+    .flush       = volicon_flush,
+    .release     = volicon_release,
+    .fsync       = volicon_fsync,
+    .setxattr    = volicon_setxattr,
+    .getxattr    = volicon_getxattr,
+    .listxattr   = volicon_listxattr,
+    .removexattr = volicon_removexattr,
+    .opendir     = volicon_opendir,
+    .readdir     = volicon_readdir,
+    .releasedir  = volicon_releasedir,
+    .fsyncdir    = volicon_fsyncdir,
+    .init        = volicon_init,
+    .destroy     = volicon_destroy,
+    .access      = volicon_access,
+    .create      = volicon_create,
+    .ftruncate   = volicon_ftruncate,
+    .fgetattr    = volicon_fgetattr,
+    .lock        = volicon_lock,
+    .utimens     = volicon_utimens,
+    .bmap        = volicon_bmap,
+};
+
+static struct fuse_opt volicon_opts[] = {
+    FUSE_OPT_KEY("-h", 0),
+    FUSE_OPT_KEY("--help", 0),
+    { "iconpath=%s", offsetof(struct volicon, volicon), 0 },
+    FUSE_OPT_END
+};
+
+static void
+volicon_help(void)
+{
+    fprintf(stderr,
+            "    -o iconpath=<icon path> display volume with custom icon\n");
+}
+
+static int
+volicon_opt_proc(void *data, const char *arg, int key,
+                 struct fuse_args *outargs)
+{
+    (void)data;
+    (void)arg;
+    (void)outargs;
+
+    if (!key) {
+        volicon_help();
+        return -1;
+    }
+
+    return 1;
+}
+
+static struct fuse_fs *
+volicon_new(struct fuse_args *args, struct fuse_fs *next[])
+{
+    int ret;
+    int voliconfd = -1;
+    struct stat sb;
+    struct fuse_fs *fs;
+    struct volicon *d;
+
+    d = calloc(1, sizeof(*d));
+    if (d == NULL) {
+        fprintf(stderr, "volicon: memory allocation failed\n");
+        return NULL;
+    }
+
+    if (fuse_opt_parse(args, d, volicon_opts, volicon_opt_proc) == -1) {
+        goto out_free;
+    }
+
+    if (!next[0] || next[1]) {
+        fprintf(stderr, "volicon: exactly one next filesystem required\n");
+        goto out_free;
+    }
+
+    if (!d->volicon) {
+        fprintf(stderr, "volicon: missing 'iconpath' option\n");
+        goto out_free;
+    }
+
+    voliconfd = open(d->volicon, O_RDONLY);
+    if (voliconfd < 0) {
+        fprintf(stderr, "volicon: failed to access volume icon file (%d)\n",
+                errno);
+        goto out_free;
+    }
+
+    ret = fstat(voliconfd, &sb);
+    if (ret) {
+        fprintf(stderr, "volicon: failed to stat volume icon file (%d)\n",
+                errno);
+        goto out_free;
+    }
+
+    if (sb.st_size > (VOLICON_ICON_MAXSIZE)) {
+        fprintf(stderr, "volicon: size limit exceeded for volume icon file\n");
+        goto out_free;
+    }
+
+    d->volicon_data = malloc(sb.st_size);
+    if (!d->volicon_data) {
+        fprintf(stderr,
+                "volicon: failed to allocate memory for volume icon data\n");
+        goto out_free;
+    }
+
+    ret = read(voliconfd, d->volicon_data, sb.st_size);
+    if (ret != sb.st_size) {
+        fprintf(stderr, "volicon: failed to read data from volume icon file\n");
+        goto out_free;
+    }
+
+    close(voliconfd);
+    voliconfd = -1;
+
+    d->volicon_size = sb.st_size;
+    d->volicon_uid = getuid();
+
+    d->next = next[0];
+
+    fs = fuse_fs_new(&volicon_oper, sizeof(volicon_oper), d);
+    if (!fs) {
+        goto out_free;
+    }
+
+    return fs;
+
+ out_free:
+
+    if (d->volicon_data) {
+        free(d->volicon_data);
+    }
+ 
+    if (voliconfd >= 0) {
+        close(voliconfd);
+    }
+
+    if (d->volicon) {
+        free(d->volicon);
+    }
+
+    free(d);
+
+    return NULL;
+}
+
+FUSE_REGISTER_MODULE(volicon, volicon_new);
diff -Naur old/lib/mount.c new/lib/mount.c
--- old/lib/mount.c	2007-07-02 04:32:17.000000000 -0700
+++ new/lib/mount.c	2007-09-16 12:14:59.000000000 -0700
@@ -579,5 +579,7 @@
     return res;
 }
 
+#if !(__FreeBSD__ >= 10)
 __asm__(".symver fuse_mount_compat22,fuse_mount@FUSE_2.2");
 __asm__(".symver fuse_unmount_compat22,fuse_unmount@FUSE_2.2");
+#endif
diff -Naur old/lib/mount_darwin.c new/lib/mount_darwin.c
--- old/lib/mount_darwin.c	1969-12-31 16:00:00.000000000 -0800
+++ new/lib/mount_darwin.c	2007-09-16 12:45:02.000000000 -0700
@@ -0,0 +1,621 @@
+/*
+ * Amit Singh <singh@>
+ * 
+ * Derived from mount_bsd.c from the fuse distribution.
+ * 
+ *  FUSE: Filesystem in Userspace
+ *  Copyright (C) 2005-2006 Csaba Henk <csaba.henk@creo.hu>
+ *
+ *  This program can be distributed under the terms of the GNU LGPL.
+ *  See the file COPYING.LIB.
+*/
+
+#undef _POSIX_C_SOURCE
+#include <sys/types.h>
+#include <CoreFoundation/CoreFoundation.h>
+
+#include "fuse_i.h"
+#include "fuse_opt.h"
+
+#include <sys/stat.h>
+#include <sys/wait.h>
+#include <sys/sysctl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <stddef.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <string.h>
+#include <paths.h>
+
+#include <libproc.h>
+#include <sys/utsname.h>
+
+#include <sys/param.h>
+#include <sys/mount.h>
+#include <AssertMacros.h>
+
+#include "macfuse.h"
+
+static const char *MacFUSE = "MacFUSE version " MACFUSE_VERSION ", " __DATE__ ", " __TIME__;
+static int quiet_mode = 0;
+
+static long
+os_version_major(void)
+{
+    int ret = 0;
+    long major = 0;
+    char *c = NULL;
+    struct utsname u;
+    size_t oldlen;
+
+    oldlen = sizeof(u.release);
+
+    ret = sysctlbyname("kern.osrelease", u.release, &oldlen, NULL, 0);
+    if (ret != 0) {
+        return -1;
+    }
+
+    c = strchr(u.release, '.');
+    if (c == NULL) {
+        return -1;
+    }
+
+    *c = '\0';
+
+    errno = 0;
+    major = strtol(u.release, NULL, 10);
+    if ((errno == EINVAL) || (errno == ERANGE)) {
+        return -1;
+    }
+
+    return major;
+}
+
+static int
+loadkmod(void)
+{
+    int result = -1;
+    int pid, terminated_pid;
+    union wait status;
+    long major;
+
+    major = os_version_major();
+
+    if (major < 9) { /* not Mac OS X 10.5+ */
+        return EINVAL;
+    }
+
+    pid = fork();
+
+    if (pid == 0) {
+        result = execl(MACFUSE_LOAD_PROG, MACFUSE_LOAD_PROG, NULL);
+        
+        /* exec failed */
+        goto Return;
+    }
+
+    require_action(pid != -1, Return, result = errno);
+
+    while ((terminated_pid = wait4(pid, (int *)&status, 0, NULL)) < 0) {
+        /* retry if EINTR, else break out with error */
+        if (errno != EINTR) {
+            break;
+        }
+    }
+
+    if ((terminated_pid == pid) && (WIFEXITED(status))) {
+        result = WEXITSTATUS(status);
+    } else {
+        result = -1;
+    }
+
+Return:
+    check_noerr_string(result, strerror(errno));
+    
+    return result;
+}
+
+static int
+post_notification(char   *name,
+                  char   *udata_keys[],
+                  char   *udata_values[],
+                  CFIndex nf_num)
+{
+    CFIndex i;
+    CFStringRef nf_name   = NULL;
+    CFStringRef nf_object = NULL;
+    CFMutableDictionaryRef nf_udata  = NULL;
+
+    CFNotificationCenterRef distributedCenter;
+    CFStringEncoding encoding = kCFStringEncodingASCII;
+
+    distributedCenter = CFNotificationCenterGetDistributedCenter();
+
+    if (!distributedCenter) {
+        return -1;
+    }
+
+    nf_name = CFStringCreateWithCString(kCFAllocatorDefault, name, encoding);
+      
+    nf_object = CFStringCreateWithCString(kCFAllocatorDefault,
+                                          LIBFUSE_UNOTIFICATIONS_OBJECT,
+                                          encoding);
+ 
+    nf_udata = CFDictionaryCreateMutable(kCFAllocatorDefault,
+                                         nf_num,
+                                         &kCFCopyStringDictionaryKeyCallBacks,
+                                         &kCFTypeDictionaryValueCallBacks);
+
+    if (!nf_name || !nf_object || !nf_udata) {
+        goto out;
+    }
+
+    for (i = 0; i < nf_num; i++) {
+        CFStringRef a_key = CFStringCreateWithCString(kCFAllocatorDefault,
+                                                      udata_keys[i],
+                                                      kCFStringEncodingASCII);
+        CFStringRef a_value = CFStringCreateWithCString(kCFAllocatorDefault,
+                                                        udata_values[i],
+                                                        kCFStringEncodingASCII);
+        CFDictionarySetValue(nf_udata, a_key, a_value);
+        CFRelease(a_key);
+        CFRelease(a_value);
+    }
+
+    CFNotificationCenterPostNotification(distributedCenter,
+                                         nf_name, nf_object, nf_udata, false);
+
+out:
+    if (nf_name) {
+        CFRelease(nf_name);
+    }
+
+    if (nf_object) {
+        CFRelease(nf_object);
+    }
+
+    if (nf_udata) {
+        CFRelease(nf_udata);
+    }
+
+    return 0;
+}
+
+enum {
+    KEY_ALLOW_ROOT,
+    KEY_DIO,
+    KEY_HELP,
+    KEY_IGNORED,
+    KEY_KERN,
+    KEY_QUIET,
+    KEY_RO,
+    KEY_VERSION,
+    KEY_VOLICON,
+};
+
+struct mount_opts {
+    int allow_other;
+    int allow_root;
+    int ishelp;
+    char *kernel_opts;
+};
+
+static const struct fuse_opt fuse_mount_opts[] = {
+    { "allow_other", offsetof(struct mount_opts, allow_other), 1 },
+    { "allow_root", offsetof(struct mount_opts, allow_root), 1 },
+    FUSE_OPT_KEY("allow_root",          KEY_ALLOW_ROOT),
+    FUSE_OPT_KEY("-r",                  KEY_RO),
+    FUSE_OPT_KEY("-h",                  KEY_HELP),
+    FUSE_OPT_KEY("--help",              KEY_HELP),
+    FUSE_OPT_KEY("-V",                  KEY_VERSION),
+    FUSE_OPT_KEY("--version",           KEY_VERSION),
+    /* standard FreeBSD mount options */
+    FUSE_OPT_KEY("dev",                 KEY_KERN),
+    FUSE_OPT_KEY("async",               KEY_KERN),
+    FUSE_OPT_KEY("atime",               KEY_KERN),
+    FUSE_OPT_KEY("dev",                 KEY_KERN),
+    FUSE_OPT_KEY("exec",                KEY_KERN),
+    FUSE_OPT_KEY("suid",                KEY_KERN),
+    FUSE_OPT_KEY("symfollow",           KEY_KERN),
+    FUSE_OPT_KEY("rdonly",              KEY_KERN),
+    FUSE_OPT_KEY("sync",                KEY_KERN),
+    FUSE_OPT_KEY("union",               KEY_KERN),
+    FUSE_OPT_KEY("userquota",           KEY_KERN),
+    FUSE_OPT_KEY("groupquota",          KEY_KERN),
+    FUSE_OPT_KEY("clusterr",            KEY_KERN),
+    FUSE_OPT_KEY("clusterw",            KEY_KERN),
+    FUSE_OPT_KEY("suiddir",             KEY_KERN),
+    FUSE_OPT_KEY("snapshot",            KEY_KERN),
+    FUSE_OPT_KEY("multilabel",          KEY_KERN),
+    FUSE_OPT_KEY("acls",                KEY_KERN),
+    FUSE_OPT_KEY("force",               KEY_KERN),
+    FUSE_OPT_KEY("update",              KEY_KERN),
+    FUSE_OPT_KEY("ro",                  KEY_KERN),
+    FUSE_OPT_KEY("rw",                  KEY_KERN),
+    FUSE_OPT_KEY("auto",                KEY_KERN),
+    /* options supported under both Linux and FBSD */
+    FUSE_OPT_KEY("allow_other",         KEY_KERN),
+    FUSE_OPT_KEY("default_permissions", KEY_KERN),
+    /* FBSD FUSE specific mount options */
+    FUSE_OPT_KEY("private",             KEY_KERN),
+    FUSE_OPT_KEY("neglect_shares",      KEY_KERN),
+    FUSE_OPT_KEY("push_symlinks_in",    KEY_KERN),
+    /* stock FBSD mountopt parsing routine lets anything be negated... */
+    FUSE_OPT_KEY("nodev",               KEY_KERN),
+    FUSE_OPT_KEY("noasync",             KEY_KERN),
+    FUSE_OPT_KEY("noatime",             KEY_KERN),
+    FUSE_OPT_KEY("nodev",               KEY_KERN),
+    FUSE_OPT_KEY("noexec",              KEY_KERN),
+    FUSE_OPT_KEY("nosuid",              KEY_KERN),
+    FUSE_OPT_KEY("nosymfollow",         KEY_KERN),
+    FUSE_OPT_KEY("nordonly",            KEY_KERN),
+    FUSE_OPT_KEY("nosync",              KEY_KERN),
+    FUSE_OPT_KEY("nounion",             KEY_KERN),
+    FUSE_OPT_KEY("nouserquota",         KEY_KERN),
+    FUSE_OPT_KEY("nogroupquota",        KEY_KERN),
+    FUSE_OPT_KEY("noclusterr",          KEY_KERN),
+    FUSE_OPT_KEY("noclusterw",          KEY_KERN),
+    FUSE_OPT_KEY("nosuiddir",           KEY_KERN),
+    FUSE_OPT_KEY("nosnapshot",          KEY_KERN),
+    FUSE_OPT_KEY("nomultilabel",        KEY_KERN),
+    FUSE_OPT_KEY("noacls",              KEY_KERN),
+    FUSE_OPT_KEY("noforce",             KEY_KERN),
+    FUSE_OPT_KEY("noupdate",            KEY_KERN),
+    FUSE_OPT_KEY("noro",                KEY_KERN),
+    FUSE_OPT_KEY("norw",                KEY_KERN),
+    FUSE_OPT_KEY("noauto",              KEY_KERN),
+    FUSE_OPT_KEY("noallow_other",       KEY_KERN),
+    FUSE_OPT_KEY("nodefault_permissions", KEY_KERN),
+    FUSE_OPT_KEY("noprivate",           KEY_KERN),
+    FUSE_OPT_KEY("noneglect_shares",    KEY_KERN),
+    FUSE_OPT_KEY("nopush_symlinks_in",  KEY_KERN),
+    /* Mac OS X options */
+    FUSE_OPT_KEY("allow_recursion",     KEY_KERN),
+    FUSE_OPT_KEY("allow_root",          KEY_KERN), /* need to pass this on */
+    FUSE_OPT_KEY("auto_xattr",          KEY_KERN),
+    FUSE_OPT_KEY("blocksize=",          KEY_KERN),
+    FUSE_OPT_KEY("daemon_timeout=",     KEY_KERN),
+    FUSE_OPT_KEY("default_permissions", KEY_KERN),
+    FUSE_OPT_KEY("defer_permissions",   KEY_KERN),
+    FUSE_OPT_KEY("direct_io",           KEY_DIO),
+    FUSE_OPT_KEY("extended_security",   KEY_KERN),
+    FUSE_OPT_KEY("fsid=",               KEY_KERN),
+    FUSE_OPT_KEY("fsname=",             KEY_KERN),
+    FUSE_OPT_KEY("fssubtype=",          KEY_KERN),
+    FUSE_OPT_KEY("init_timeout=",       KEY_KERN),
+    FUSE_OPT_KEY("iosize=",             KEY_KERN),
+    FUSE_OPT_KEY("jail_symlinks",       KEY_KERN),
+    FUSE_OPT_KEY("kill_on_unmount",     KEY_KERN),
+    FUSE_OPT_KEY("noalerts",            KEY_KERN),
+    FUSE_OPT_KEY("noappledouble",       KEY_KERN),
+    FUSE_OPT_KEY("noapplexattr",        KEY_KERN),
+    FUSE_OPT_KEY("noattrcache",         KEY_KERN),
+    FUSE_OPT_KEY("nobrowse",            KEY_KERN),
+    FUSE_OPT_KEY("nolocalcaches",       KEY_KERN),
+    FUSE_OPT_KEY("noping_diskarb",      KEY_IGNORED),
+    FUSE_OPT_KEY("noreadahead",         KEY_KERN),
+    FUSE_OPT_KEY("nosynconclose",       KEY_KERN),
+    FUSE_OPT_KEY("nosyncwrites",        KEY_KERN),
+    FUSE_OPT_KEY("noubc",               KEY_KERN),
+    FUSE_OPT_KEY("novncache",           KEY_KERN),
+    FUSE_OPT_KEY("ping_diskarb",        KEY_IGNORED),
+    FUSE_OPT_KEY("quiet",               KEY_QUIET),
+    FUSE_OPT_KEY("subtype=",            KEY_IGNORED),
+    FUSE_OPT_KEY("volicon=",            KEY_VOLICON),
+    FUSE_OPT_KEY("volname=",            KEY_KERN),
+    FUSE_OPT_END
+};
+
+static void
+mount_help(void)
+{
+    system(MACFUSE_MOUNT_PROG " --help");
+    fputc('\n', stderr);
+}
+
+static void
+mount_version(void)
+{
+    system(MACFUSE_MOUNT_PROG " --version");
+}
+
+static int
+fuse_mount_opt_proc(void *data, const char *arg, int key,
+                    struct fuse_args *outargs)
+{
+    struct mount_opts *mo = data;
+
+    switch (key) {
+
+    case KEY_ALLOW_ROOT:
+        if (fuse_opt_add_opt(&mo->kernel_opts, "allow_other") == -1 ||
+            fuse_opt_add_arg(outargs, "-oallow_root") == -1)
+            return -1;
+        return 0;
+
+    case KEY_RO:
+        arg = "ro";
+        /* fall through */
+
+    case KEY_KERN:
+        return fuse_opt_add_opt(&mo->kernel_opts, arg);
+
+    case KEY_DIO:
+          if (fuse_opt_add_opt(&mo->kernel_opts, "direct_io") == -1 ||
+              (fuse_opt_add_arg(outargs, "-odirect_io") == -1))
+            return -1;
+        return 0;
+
+    case KEY_IGNORED:
+        return 0;
+
+    case KEY_QUIET:
+        quiet_mode = 1;
+        return 0;
+
+    case KEY_VOLICON:
+    {
+        char volicon_arg[MAXPATHLEN + 32];
+        char *volicon_path = strchr(arg, '=');
+        if (!volicon_path) {
+            return -1;
+        }
+        if (snprintf(volicon_arg, sizeof(volicon_arg), 
+                     "-omodules=volicon,iconpath%s", volicon_path) <= 0) {
+            return -1;
+        }
+        if (fuse_opt_add_arg(outargs, volicon_arg) == -1) {
+            return -1;
+        }
+
+        return 0;
+    }
+
+    case KEY_HELP:
+        mount_help();
+        mo->ishelp = 1;
+        break;
+
+    case KEY_VERSION:
+        mount_version();
+        mo->ishelp = 1;
+        break;
+    }
+    return 1;
+}
+
+void
+fuse_kern_unmount(const char *mountpoint, int fd)
+{
+    int ret;
+    struct stat sbuf;
+    char dev[128];
+    char resolved_path[PATH_MAX];
+    char *ep, *rp = NULL, *umount_cmd;
+
+    unsigned int hs_complete = 0;
+
+    ret = ioctl(fd, FUSEDEVIOCGETHANDSHAKECOMPLETE, &hs_complete);
+    if (ret || !hs_complete) {
+        return;
+    }
+
+    if (fstat(fd, &sbuf) == -1) {
+        return;
+    }
+
+    devname_r(sbuf.st_rdev, S_IFCHR, dev, 128);
+
+    if (strncmp(dev, MACFUSE_DEVICE_BASENAME,
+                sizeof(MACFUSE_DEVICE_BASENAME) - 1)) {
+        return;
+    }
+
+    strtol(dev + 4, &ep, 10);
+    if (*ep != '\0') {
+        return;
+    }
+
+    rp = realpath(mountpoint, resolved_path);
+    if (rp) {
+        ret = unmount(resolved_path, 0);
+    }
+
+    return;
+}
+
+static int
+fuse_mount_core(const char *mountpoint, const char *opts)
+{
+    int fd, pid;
+    int result;
+    char *fdnam, *dev;
+    const char *mountprog = MACFUSE_MOUNT_PROG;
+
+    if (!mountpoint) {
+        fprintf(stderr, "missing or invalid mount point\n");
+        return -1;
+    }
+
+    result = loadkmod();
+    if (result) {
+        CFOptionFlags responseFlags;
+        if (result == EINVAL) {
+            if (!quiet_mode) {
+                CFUserNotificationDisplayNotice(
+                    (CFTimeInterval)0,
+                    kCFUserNotificationCautionAlertLevel,
+                    (CFURLRef)0,
+                    (CFURLRef)0,
+                    (CFURLRef)0,
+                    CFSTR("Operating System Too Old"),
+                    CFSTR("The installed MacFUSE version is too new for the operating system. Please downgrade your MacFUSE installation to one that is compatible with the currently running operating system."),
+                    CFSTR("OK")
+                );
+            }
+            post_notification(
+                LIBFUSE_UNOTIFICATIONS_NOTIFY_OSISTOOOLD, NULL, NULL, 0);
+        } else if (result == EBUSY) {
+            if (!quiet_mode) {
+                CFUserNotificationDisplayNotice(
+                    (CFTimeInterval)0,
+                    kCFUserNotificationCautionAlertLevel,
+                    (CFURLRef)0,
+                    (CFURLRef)0,
+                    (CFURLRef)0,
+                    CFSTR("MacFUSE Version Mismatch"),
+                    CFSTR("MacFUSE has been updated but an incompatible or old version of the MacFUSE kernel extension is already loaded. It failed to unload, possibly because a MacFUSE volume is currently mounted.\n\nPlease eject all MacFUSE volumes and try again, or simply restart the system for changes to take effect."),
+                    CFSTR("OK")
+                );
+            }
+            post_notification(LIBFUSE_UNOTIFICATIONS_NOTIFY_VERSIONMISMATCH,
+                              NULL, NULL, 0);
+        }
+        fprintf(stderr, "the MacFUSE file system is not available (%d)\n",
+                result);
+        return -1;
+    }
+
+    fdnam = getenv("FUSE_DEV_FD");
+
+    if (fdnam) {
+
+        char *ep;
+
+        fd = strtol(fdnam, &ep, 10);
+
+        if (*ep != '\0') {
+            fprintf(stderr, "invalid value given in FUSE_DEV_FD\n");
+            return -1;
+        }
+
+        if (fd < 0)
+            return -1;
+
+        goto mount;
+    }
+
+    dev = getenv("FUSE_DEV_NAME");
+
+    if (dev) {
+        if ((fd = open(dev, O_RDWR)) < 0) {
+            perror("MacFUSE: failed to open device");
+            return -1;
+        }
+    } else {
+        int r, devidx = -1;
+        char devpath[MAXPATHLEN];
+
+        for (r = 0; r < MACFUSE_NDEVICES; r++) {
+            snprintf(devpath, MAXPATHLEN - 1,
+                     _PATH_DEV MACFUSE_DEVICE_BASENAME "%d", r);
+            fd = open(devpath, O_RDWR);
+            if (fd >= 0) {
+                dev = devpath;
+                devidx = r;
+                break;
+            }
+        }
+        if (devidx == -1) {
+            perror("MacFUSE: failed to open device");
+            return -1;
+        }
+    }
+
+mount:
+    if (getenv("FUSE_NO_MOUNT") || ! mountpoint)
+        goto out;
+
+    signal(SIGCHLD, SIG_IGN);
+
+    pid = fork();
+
+    if (pid == -1) {
+        perror("MacFUSE: fork() failed");
+        close(fd);
+        return -1;
+    }
+
+    if (pid == 0) {
+
+        pid = fork();
+        if (pid == -1) {
+            perror("MacFUSE: fork() failed");
+            close(fd);
+            exit(1);
+        }
+
+        if (pid == 0) {
+            const char *argv[32];
+            int a = 0;
+
+            if (! fdnam)
+                asprintf(&fdnam, "%d", fd);
+
+            argv[a++] = mountprog;
+            if (opts) {
+                argv[a++] = "-o";
+                argv[a++] = opts;
+            }
+            argv[a++] = fdnam;
+            argv[a++] = mountpoint;
+            argv[a++] = NULL;
+
+            {
+                char title[MAXPATHLEN + 1] = { 0 };
+                u_int32_t len = MAXPATHLEN;
+                int ret = proc_pidpath(getpid(), title, len);
+                if (ret) {
+                    setenv("MOUNT_FUSEFS_DAEMON_PATH", title, 1);
+                }
+            }
+            execvp(mountprog, (char **) argv);
+            perror("MacFUSE: failed to exec mount_fusefs program");
+            exit(1);
+        }
+
+        exit(0);
+    }
+
+out:
+    return fd;
+}
+
+int
+fuse_kern_mount(const char *mountpoint, struct fuse_args *args)
+{
+    struct mount_opts mo;
+    int res = -1;
+
+    memset(&mo, 0, sizeof(mo));
+
+    /* mount_fusefs should not try to spawn the daemon */
+    setenv("MOUNT_FUSEFS_SAFE", "1", 1);
+
+    /* to notify mount_fusefs it's called from lib */
+    setenv("MOUNT_FUSEFS_CALL_BY_LIB", "1", 1);
+
+    if (args &&
+        fuse_opt_parse(args, &mo, fuse_mount_opts, fuse_mount_opt_proc) == -1) {
+        return -1;
+    }
+
+    if (mo.allow_other && mo.allow_root) {
+        fprintf(stderr,
+                "MacFUSE: allow_other and allow_root are mutually exclusive\n");
+        goto out;
+    }
+
+    if (mo.ishelp) {
+        return 0;
+    }
+
+    res = fuse_mount_core(mountpoint, mo.kernel_opts);
+
+out:
+    free(mo.kernel_opts);
+
+    return res;
+}
diff -Naur old/lib/ulockmgr.c new/lib/ulockmgr.c
--- old/lib/ulockmgr.c	2007-07-02 04:32:17.000000000 -0700
+++ new/lib/ulockmgr.c	2007-09-16 12:14:59.000000000 -0700
@@ -18,9 +18,19 @@
 #include <assert.h>
 #include <signal.h>
 #include <sys/stat.h>
+#if (__FreeBSD__ >= 10)
+#undef _POSIX_C_SOURCE
 #include <sys/socket.h>
+#define _POSIX_C_SOURCE 200112L
+#else
+#include <sys/socket.h>
+#endif
 #include <sys/wait.h>
 
+#if (__FreeBSD__ >= 10)
+#define MSG_NOSIGNAL 0
+#endif
+
 struct message {
     unsigned intr : 1;
     unsigned nofd : 1;
@@ -140,6 +150,13 @@
         return -1;
     }
     ulockmgr_cfd = sv[1];
+#if (__FreeBSD__ >= 10)
+    {
+        int on = 1;
+        res = setsockopt(ulockmgr_cfd, SOL_SOCKET, SO_NOSIGPIPE, (void *)&on,
+                         sizeof(on));
+    }
+#endif
     return 0;
 }
 
