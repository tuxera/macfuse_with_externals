//
//  KSDownloadAction.m
//  Keystone
//
//  Created by Greg Miller on 1/23/08.
//  Copyright 2008 Google Inc. All rights reserved.
//

#import "KSDownloadAction.h"
#import "KSActionProcessor.h"
#import "KSActionPipe.h"
#import "GTMLogger.h"
#import "NSData+Hash.h"
#import "GTMBase64.h"
#import "KSUUID.h"
#import "GTMPath.h"
#import "GTMNSString+FindFolder.h"
#import "KSFrameworkStats.h"
#import <unistd.h>


// Overview of secure downloading
// ------------------------------
//
// This action needs to download a URL, save the data to a file, and verify the
// contents of the file by checking it's SHA-1 hash value. To protect ourselves
// in the event that root is doing the download, we fork another process
// ("ksurl") which does the actual network transactions for the download, then
// when it's done we proceed to verify the download. To ensure we always use the
// "same" code path, we use the separate ksurl process even if we're not running
// as root.
//
// These security requirements have led us to the following design of this code:
// 
// 1. Before forking the child process we mark all of our file descriptors as
//    close-on-exec to make sure we don't leak FDs to an unprivileged process
// 2. We erase the child's environment when NSTask'ing
// 3. The child (ksurl) itself will change UID to non-root if being run as root.
//    If ksurl was not run as root, then it continues to run as the non-root
//    user who invoked it.
// 4. Our child ksurl downloads the file to a temporary path at an essentially
//    world-writable location (tempPath_).
// 5. When the child finishes downloading, this process (possibly running as
//    root) will *copy* the downloaded file from the world-writable location to
//    a secure location that's only writable by this user (perhaps root) to
//    prevent tampering with the file (path_).
// 6. Once the file is in a secure location, this process (again, possibly root)
//    will verify that file's SHA-1 hash value.
//
// Assuming the hash value is OK, then we know we have a valid file and it's
// stored in a safe location. At this point, it should be OK to report that the
// download was a success.


@interface KSDownloadAction (PrivateMethods)

// Returns YES if the file at |path| has a size of |size_| and a hash value of
// |hash_|. NO otherwise.
- (BOOL)isFileAtPathValid:(NSString *)path;

// Returns a base64 encoded SHA-1 has of the contents of the file at |path|.
- (NSString *)hashOfFileAtPath:(NSString *)path;

// Returns the size of the file in bytes (as obtained from NSFileManager)
- (unsigned long long)sizeOfFileAtPath:(NSString *)path;

// Returns the full path to the "ksurl" command.
- (NSString *)ksurlPath;

@end


// Returns a path to a file in a "writable" location. The returned path name is
// generated by the last path component of |path| (i.e., path's filename) and
// a UUID to make the returned name unique. This is the path where the 'ksurl'
// process will download to.
static NSString *WritableTempName(NSString *path) {
  if (path == nil) return nil;
  short domain = geteuid() == 0 ? kLocalDomain : kUserDomain;
  NSString *uniqueName = [NSString stringWithFormat:@"%@-%@",
                          [path lastPathComponent], [KSUUID uuidString]];
  NSString *cacheDir =
    [NSString gtm_stringWithPathForFolder:kCachedDataFolderType
                            subfolderName:@"Google"
                                 inDomain:domain
                                 doCreate:YES];
  return [cacheDir stringByAppendingPathComponent:uniqueName];
}

// Marks all the file descriptors in this process as "close-on-exec". This 
// ensures that we don't leak FDs to untrusted child processes.
static void MarkFileDescriptorsCloseOnExec(void) {
  long maxfd = sysconf(_SC_OPEN_MAX);
  if (maxfd < 0) {
    // COV_NF_START
    GTMLoggerError(@"sysconf(_SC_OPEN_MAX) failed: %s", strerror(errno));
    maxfd = 255;  // Use a reasonable default
    // COV_NF_END
  }
  for (int i = 0; i < maxfd; i++)
    fcntl(i, FD_CLOEXEC);
}


@implementation KSDownloadAction

+ (NSString *)defaultDownloadDirectory {
  short domain = geteuid() == 0 ? kLocalDomain : kUserDomain;
  NSBundle *bundle = [NSBundle bundleForClass:[KSDownloadAction class]];
  NSString *name = [NSString stringWithFormat:@"%@.%d",
                    [bundle bundleIdentifier], geteuid()];
  
  NSString *caches = [NSString gtm_stringWithPathForFolder:kCachedDataFolderType
                                                  inDomain:domain
                                                  doCreate:YES];
  
  GTMPath *downloads = [[[GTMPath pathWithFullPath:caches]
                         createDirectoryName:name mode:0700]
                        createDirectoryName:@"Downloads" mode:0700];
  
  // This mode is important. Make sure it's correct before continuing.
  if ([[downloads attributes] filePosixPermissions] != 0700) {
    GTMLoggerError(@"Bad mode on %@, can't use", downloads);
    return nil;
  }

  return [downloads fullPath];
}

+ (id)actionWithURL:(NSURL *)url
               size:(unsigned long long)size
               hash:(NSString *)hash
               name:(NSString *)name {
  NSString *dir = [self defaultDownloadDirectory];
  NSString *path = [dir stringByAppendingPathComponent:name];
  return [self actionWithURL:url size:size hash:hash path:path];
}

+ (id)actionWithURL:(NSURL *)url
               size:(unsigned long long)size
               hash:(NSString *)hash
               path:(NSString *)path {
  return [[[self alloc] initWithURL:url
                               size:size
                               hash:hash
                               path:path] autorelease];
}

- (id)init {
  return [self initWithURL:nil size:0 hash:nil path:nil];
}

- (id)initWithURL:(NSURL *)url
             size:(unsigned long long)size
             hash:(NSString *)hash
             path:(NSString *)path {
  if ((self = [super init])) {
    url_ = [url retain];
    size_ = size;
    hash_ = [hash retain];
    path_ = [path copy];
    tempPath_ = [WritableTempName(path_) copy];
    
    if (url_ == nil || size_ == 0 || [hash_ length] == 0 || 
        [path_ length] == 0 || [tempPath_ length] == 0) {
      GTMLoggerDebug(@"created with illegal argument: "
                     @"url=%@, size=%llu, hash=%@, destinationPath=%@",
                     url_, size_, hash_, path_);
      [self release];
      return nil;
    }
  }
  return self;
}

- (void)dealloc {
  [url_ release];
  [hash_ release];
  [path_ release];
  [tempPath_ release];
  [[NSNotificationCenter defaultCenter] removeObserver:self];
  [downloadTask_ terminate];
  [downloadTask_ release];
  [super dealloc];
}

- (NSURL *)url {
  return url_;
}

- (unsigned long long)size {
  return size_;
}

- (NSString *)hash {
  return hash_;
}

- (NSString *)path {
  return path_;
}

- (void)performAction {
  // Assert class invariants that we care about here
  _GTMDevAssert(url_ != nil, @"url_ must not be nil");
  _GTMDevAssert(hash_ != nil, @"hash_ must not be nil");
  _GTMDevAssert(size_ != 0, @"size_ must not be 0");
  _GTMDevAssert(path_ != nil, @"destination path must not be nil");
  _GTMDevAssert(tempPath_ != nil, @"tempPath_ must not be nil");
  _GTMDevAssert(downloadTask_ == nil, @"downloadTask_ must be nil");
    
  // If we've already downloaded the file, then we can short circuit the
  // download and just return the one that we already have.
  if ([self isFileAtPathValid:path_]) {
    GTMLoggerInfo(@"Short circuiting download of %@, path=%@, "
                  @"size=%llu, hash=%@", url_, path_, size_, hash_);
    [[self outPipe] setContents:path_];
    [[self processor] finishedProcessing:self successfully:YES];
    [[KSFrameworkStats sharedStats] incrementStat:kStatDownloadCacheHits];
    return;  // Short circuit
  }

  NSString *ksurlPath = [self ksurlPath];
  NSArray *args = [NSArray arrayWithObjects:
                   @"-url", [url_ description],
                   @"-path", tempPath_, nil];
  
  downloadTask_ = [[NSTask alloc] init];
  [downloadTask_ setLaunchPath:ksurlPath];
  [downloadTask_ setEnvironment:[NSDictionary dictionary]];
  [downloadTask_ setCurrentDirectoryPath:@"/tmp/"];
  [downloadTask_ setArguments:args];
  
  GTMLoggerInfo(@"Running '%@ %@'", ksurlPath,
                [args componentsJoinedByString:@" "]);
  
  MarkFileDescriptorsCloseOnExec();
  
  [[NSNotificationCenter defaultCenter] removeObserver:self];
  [[NSNotificationCenter defaultCenter] addObserver:self
                                           selector:@selector(taskExited:)
                                               name:NSTaskDidTerminateNotification
                                             object:downloadTask_];
  
  @try {
    // Is known to throw if launchPath is not executable
    [downloadTask_ launch];
    [[KSFrameworkStats sharedStats] incrementStat:kStatDownloads];
  // COV_NF_START
  }
  @catch (id ex) {
    // It's not really feasible to test the case where this throws because we'd
    // need to delete the installation of ksurl during the unit test, which 
    // may break further tests that rely on it. Or we could move it and move
    // it back, but really, ugh.
    GTMLoggerError(@"Failed to launch %@ %@: %@", ksurlPath,
                   [args componentsJoinedByString:@" "], ex);
    [[NSNotificationCenter defaultCenter] removeObserver:self];
    [downloadTask_ release];
    downloadTask_ = nil;
    [[self processor] finishedProcessing:self successfully:NO];
  }
  // COV_NF_END
}

- (void)terminateAction {
  if (![self isRunning])
    return;
  
  GTMLoggerInfo(@"Cancelling download task %@ (%@ %@) at the behest of %@",
                downloadTask_, [downloadTask_ launchPath],
                [[downloadTask_ arguments] componentsJoinedByString:@" "], 
                [self processor]);
  
  [[NSNotificationCenter defaultCenter] removeObserver:self];
  [downloadTask_ terminate];
  [downloadTask_ waitUntilExit];
  [downloadTask_ release];
  downloadTask_ = nil;
}

- (void)taskExited:(NSNotification *)notification {
  _GTMDevAssert(path_ != nil, @"path_ must not be nil");
  _GTMDevAssert(tempPath_ != nil, @"tempPath_ must not be nil");
  
  BOOL verified = NO;
  int status = [downloadTask_ terminationStatus];

  if (status == 0) {
    // Move tempPath_ into our safe, non-public location pointed at by path_
    // Why do we use unlink(2) instead of NSFileManager? Because NSFM will remove
    // directories recursively, and if some crazy accident happend where one of 
    // these paths pointed to a dir (say, "/"), we'd rather it fail than
    // recursively remove things.
    NSFileManager *fm = [NSFileManager defaultManager];
    unlink([path_ fileSystemRepresentation]);  // Remove destination path
    if (![fm copyPath:tempPath_ toPath:path_ handler:nil]) {
      GTMLoggerError(@"Failed to rename %@ -> %@: errno=%d",  // COV_NF_LINE
                     tempPath_, path_, errno);                // COV_NF_LINE
    }
    unlink([tempPath_ fileSystemRepresentation]);  // Clean up source path
    
    verified = [self isFileAtPathValid:path_];
  }
  
  if (verified)
    [[self outPipe] setContents:path_];
  else
    [[KSFrameworkStats sharedStats] incrementStat:kStatFailedDownloads];
  
  GTMLoggerDebug(@"Task %d finished status=%d, verified=%d",
                 [downloadTask_ processIdentifier], status, verified);
  
  [[self processor] finishedProcessing:self successfully:verified];
  
  [[NSNotificationCenter defaultCenter] removeObserver:self];
  [downloadTask_ release];
  downloadTask_ = nil;
}

- (NSString *)description {
  return [NSString stringWithFormat:@"<%@:%p url=%@ size=%llu hash=%@ ...>",
                   [self class], self, url_, size_, hash_];
}

@end  // KSDownloadAction


@implementation KSDownloadAction (PrivateMethods)

- (BOOL)isFileAtPathValid:(NSString *)path {
  if (path == nil) return NO;
  unsigned long long size = [self sizeOfFileAtPath:path];
  NSString *hash = [self hashOfFileAtPath:path];
  return (size_ == size) && ([hash_ isEqualToString:hash]);
}

// Reads in a whole file and returns the base64 encoded SHA-1 hash of the data.
// If we start working with HUGE files, then we may need to change this method
// to stream the data from the file and hash it w/o reading the whole thing in.
// For now, this should work fine.
- (NSString *)hashOfFileAtPath:(NSString *)path {
  if (path == nil) return nil;
  
  NSData *data = [NSData dataWithContentsOfFile:path];
  NSData *hash = [data SHA1Hash];
  
  return [GTMBase64 stringByEncodingData:hash];
}

- (unsigned long long)sizeOfFileAtPath:(NSString *)path {
  if (path == nil) return 0;
  return [[[NSFileManager defaultManager] fileAttributesAtPath:path
                                                  traverseLink:NO] fileSize];
}

// This methods returns the path to the "ksurl" binary that's bundled as a
// Keystone.framework resource.
- (NSString *)ksurlPath {
  NSBundle *bundle = [NSBundle bundleForClass:[KSDownloadAction class]];
  NSString *ksurl = [bundle pathForResource:@"ksurl" ofType:@""];
  if (![[NSFileManager defaultManager] isExecutableFileAtPath:ksurl]) {
    GTMLoggerError(@"No executable found at %@", ksurl);  // COV_NF_LINE
    return @"/dev/null";  // Never return nil            // COV_NF_LINE
  }
  return ksurl;
}

@end  // KSDownloadAction (PrivateMethods)
